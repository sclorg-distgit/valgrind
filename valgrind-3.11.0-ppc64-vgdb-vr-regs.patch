commit 42d961c3744b2afb236c4fd3d2b59eb61421b9a8
Author: carll <carll@a5019735-40e9-0310-863c-91ae7b9d1cf9>
Date:   Thu Apr 21 18:21:26 2016 +0000

    PPC64, Valgrind with GDB does not display 64-bit and 128-bit registers
    correctly
    
    1)  Fix Endianess issue that was missed in the BE to LE port.  GDB was
        not displaying the contents of the 64-bit and 128-bit registers
        correctly due to an Endianess issue.
    
    2)  Fix displaying the shadow registers for the 64-bit and 128-bit
        registers.
    
    Bugzilla 360008 was opened for this issue.
    
    git-svn-id: svn://svn.valgrind.org/valgrind/trunk@15864 a5019735-40e9-0310-863c-91ae7b9d1cf9

diff --git a/coregrind/Makefile.am b/coregrind/Makefile.am
index d29f954..00d9fc7 100644
--- a/coregrind/Makefile.am
+++ b/coregrind/Makefile.am
@@ -605,12 +605,17 @@ GDBSERVER_XML_FILES = \
 	m_gdbserver/power64-core-valgrind-s1.xml \
 	m_gdbserver/power64-core-valgrind-s2.xml \
 	m_gdbserver/power64-core.xml \
+	m_gdbserver/power64-core2-valgrind-s1.xml \
+	m_gdbserver/power64-core2-valgrind-s2.xml \
 	m_gdbserver/power64-linux-valgrind-s1.xml \
 	m_gdbserver/power64-linux-valgrind-s2.xml \
 	m_gdbserver/power64-linux.xml \
 	m_gdbserver/power-altivec-valgrind-s1.xml \
 	m_gdbserver/power-altivec-valgrind-s2.xml \
 	m_gdbserver/power-altivec.xml \
+	m_gdbserver/power-vsx-valgrind-s1.xml \
+	m_gdbserver/power-vsx-valgrind-s2.xml \
+	m_gdbserver/power-vsx.xml \
 	m_gdbserver/power-core-valgrind-s1.xml \
 	m_gdbserver/power-core-valgrind-s2.xml \
 	m_gdbserver/power-core.xml \
diff --git a/coregrind/m_gdbserver/power-altivec.xml b/coregrind/m_gdbserver/power-altivec.xml
index 45d31af..d416075 100644
--- a/coregrind/m_gdbserver/power-altivec.xml
+++ b/coregrind/m_gdbserver/power-altivec.xml
@@ -19,7 +19,7 @@
     <field name="v16_int8" type="v16i8"/>
   </union>
 
-  <reg name="vr0" bitsize="128" type="vec128"/>
+  <reg name="vr0" bitsize="128" type="vec128" regnum="73"/>
   <reg name="vr1" bitsize="128" type="vec128"/>
   <reg name="vr2" bitsize="128" type="vec128"/>
   <reg name="vr3" bitsize="128" type="vec128"/>
diff --git a/coregrind/m_gdbserver/power-fpu-valgrind-s1.xml b/coregrind/m_gdbserver/power-fpu-valgrind-s1.xml
index 00d9108..a23d550 100644
--- a/coregrind/m_gdbserver/power-fpu-valgrind-s1.xml
+++ b/coregrind/m_gdbserver/power-fpu-valgrind-s1.xml
@@ -7,7 +7,7 @@
 
 <!DOCTYPE feature SYSTEM "gdb-target.dtd">
 <feature name="org.gnu.gdb.power.fpu-valgrind-s1">
-  <reg name="f0s1" bitsize="64" type="uint64" regnum="32"/>
+  <reg name="f0s1" bitsize="64" type="uint64"/>
   <reg name="f1s1" bitsize="64" type="uint64"/>
   <reg name="f2s1" bitsize="64" type="uint64"/>
   <reg name="f3s1" bitsize="64" type="uint64"/>
@@ -40,5 +40,5 @@
   <reg name="f30s1" bitsize="64" type="uint64"/>
   <reg name="f31s1" bitsize="64" type="uint64"/>
 
-  <reg name="fpscrs1" bitsize="32" group="float" regnum="70"/>
+  <reg name="fpscrs1" bitsize="32" group="float"/>
 </feature>
diff --git a/coregrind/m_gdbserver/power-fpu-valgrind-s2.xml b/coregrind/m_gdbserver/power-fpu-valgrind-s2.xml
index a12fa6e..45e434c 100644
--- a/coregrind/m_gdbserver/power-fpu-valgrind-s2.xml
+++ b/coregrind/m_gdbserver/power-fpu-valgrind-s2.xml
@@ -7,7 +7,7 @@
 
 <!DOCTYPE feature SYSTEM "gdb-target.dtd">
 <feature name="org.gnu.gdb.power.fpu-valgrind-s2">
-  <reg name="f0s2" bitsize="64" type="uint64" regnum="32"/>
+  <reg name="f0s2" bitsize="64" type="uint64"/>
   <reg name="f1s2" bitsize="64" type="uint64"/>
   <reg name="f2s2" bitsize="64" type="uint64"/>
   <reg name="f3s2" bitsize="64" type="uint64"/>
@@ -40,5 +40,5 @@
   <reg name="f30s2" bitsize="64" type="uint64"/>
   <reg name="f31s2" bitsize="64" type="uint64"/>
 
-  <reg name="fpscrs2" bitsize="32" group="float" regnum="70"/>
+  <reg name="fpscrs2" bitsize="32" group="float"/>
 </feature>
diff --git a/coregrind/m_gdbserver/power64-core-valgrind-s1.xml b/coregrind/m_gdbserver/power64-core-valgrind-s1.xml
index f6296bf..857e9da 100644
--- a/coregrind/m_gdbserver/power64-core-valgrind-s1.xml
+++ b/coregrind/m_gdbserver/power64-core-valgrind-s1.xml
@@ -40,10 +40,29 @@
   <reg name="r30s1" bitsize="64" type="uint64"/>
   <reg name="r31s1" bitsize="64" type="uint64"/>
 
-  <reg name="pcs1" bitsize="64" type="code_ptr" regnum="64"/>
+<!--  When printing the non-shadow register names/contents, GDB prints the
+      GPRs followed by the floating point registers then the pc, msr, ...
+      registers. If the shadow GPRs and shadow pc/msr/cr... register
+      definitions are all in this file, as is done with the non-shadow register
+      definitions, the shadow register name print order changes to GPRs,
+      followed by pc/msr/cr... then the floating point registers.  Note, the
+      contents of the shadow registers still print in this same order as the
+      non-shadow registers values resulting in the shadow register names and
+      shadow register values not correctly aligning.
+
+      In order to get, the shadow register names to print in the same order
+      as the non-shadow register and correctly align with their contents,
+      the following register definitions were moved to the file
+      power64-core2-valgrind-s1.xml. The new file is included after the shadow
+      floating point XML definition file. By doing this, we get GDB to print
+      the shadow register names in the same order as the non-shadow register
+      names and thus correctly align with the order that the shadow register
+      contents are printed.   -->
+
+<!--  <reg name="pcs1" bitsize="64" type="code_ptr"/>
   <reg name="msrs1" bitsize="64" type="uint64"/>
   <reg name="crs1" bitsize="32" type="uint32"/>
   <reg name="lrs1" bitsize="64" type="code_ptr"/>
   <reg name="ctrs1" bitsize="64" type="uint64"/>
-  <reg name="xers1" bitsize="32" type="uint32"/>
+  <reg name="xers1" bitsize="32" type="uint32"/> -->
 </feature>
diff --git a/coregrind/m_gdbserver/power64-core-valgrind-s2.xml b/coregrind/m_gdbserver/power64-core-valgrind-s2.xml
index 663232e..3825c67 100644
--- a/coregrind/m_gdbserver/power64-core-valgrind-s2.xml
+++ b/coregrind/m_gdbserver/power64-core-valgrind-s2.xml
@@ -40,10 +40,29 @@
   <reg name="r30s2" bitsize="64" type="uint64"/>
   <reg name="r31s2" bitsize="64" type="uint64"/>
 
-  <reg name="pcs2" bitsize="64" type="code_ptr" regnum="64"/>
+<!--  When printing the non-shadow register names/contents, GDB prints the
+      GPRs followed by the floating point registers then the pc, msr, ...
+      registers. If the shadow GPRs and shadow pc/msr/cr... register
+      definitions are all in this file, as is done with the non-shadow register
+      definitions, the shadow register name print order changes to GPRs,
+      followed by pc/msr/cr... then the floating point registers.  Note, the
+      contents of the shadow registers still print in this same order as the
+      non-shadow registers values resulting in the shadow register names and
+      shadow register values not correctly aligning.
+
+      In order to get, the shadow register names to print in the same order
+      as the non-shadow register and correctly align with their contents,
+      the following register definitions were moved to the file
+      power64-core2-valgrind-s2.xml. The new file is included after the shadow
+      floating point XML definition file. By doing this, we get GDB to print
+      the shadow register names in the same order as the non-shadow register
+      names and thus correctly align with the order that the shadow register
+      contents are printed.   -->
+
+<!--  <reg name="pcs2" bitsize="64" type="code_ptr"/>
   <reg name="msrs2" bitsize="64" type="uint64"/>
   <reg name="crs2" bitsize="32" type="uint32"/>
   <reg name="lrs2" bitsize="64" type="code_ptr"/>
   <reg name="ctrs2" bitsize="64" type="uint64"/>
-  <reg name="xers2" bitsize="32" type="uint32"/>
+  <reg name="xers2" bitsize="32" type="uint32"/>  -->
 </feature>
diff --git a/coregrind/m_gdbserver/power64-core.xml b/coregrind/m_gdbserver/power64-core.xml
index e0a6ee3..c5cfb3b 100644
--- a/coregrind/m_gdbserver/power64-core.xml
+++ b/coregrind/m_gdbserver/power64-core.xml
@@ -40,6 +40,13 @@
   <reg name="r30" bitsize="64" type="uint64"/>
   <reg name="r31" bitsize="64" type="uint64"/>
 
+<!-- Note, the following register definitions must be in this file by
+     the "standard target features" for this processor.  GDB will reject
+     this file description if the following register definitions are
+     not in this file.  Hence, they can't be moved to power64-core2.xml
+     for consistency with what was done for the shadow register definitions
+     to get the shadow register print order to match the print order of
+     the HW registers -->
   <reg name="pc" bitsize="64" type="code_ptr" regnum="64"/>
   <reg name="msr" bitsize="64" type="uint64"/>
   <reg name="cr" bitsize="32" type="uint32"/>
diff --git a/coregrind/m_gdbserver/power64-linux-valgrind-s1.xml b/coregrind/m_gdbserver/power64-linux-valgrind-s1.xml
index 7f1d0ac..736c1e7 100644
--- a/coregrind/m_gdbserver/power64-linux-valgrind-s1.xml
+++ b/coregrind/m_gdbserver/power64-linux-valgrind-s1.xml
@@ -7,6 +7,6 @@
 
 <!DOCTYPE feature SYSTEM "gdb-target.dtd">
 <feature name="org.gnu.gdb.power.linux-valgrind-s1">
-  <reg name="orig_r3s1" bitsize="64" regnum="71"/>
+  <reg name="orig_r3s1" bitsize="64"/>
   <reg name="traps1" bitsize="64"/>
 </feature>
diff --git a/coregrind/m_gdbserver/power64-linux-valgrind-s2.xml b/coregrind/m_gdbserver/power64-linux-valgrind-s2.xml
index 007bd04..626a59c 100644
--- a/coregrind/m_gdbserver/power64-linux-valgrind-s2.xml
+++ b/coregrind/m_gdbserver/power64-linux-valgrind-s2.xml
@@ -7,6 +7,6 @@
 
 <!DOCTYPE feature SYSTEM "gdb-target.dtd">
 <feature name="org.gnu.gdb.power.linux-valgrind-s2">
-  <reg name="orig_r3s2" bitsize="64" regnum="71"/>
+  <reg name="orig_r3s2" bitsize="64"/>
   <reg name="traps2" bitsize="64"/>
 </feature>
diff --git a/coregrind/m_gdbserver/powerpc-altivec64l-valgrind.xml b/coregrind/m_gdbserver/powerpc-altivec64l-valgrind.xml
index a2cd615..7760e3d 100644
--- a/coregrind/m_gdbserver/powerpc-altivec64l-valgrind.xml
+++ b/coregrind/m_gdbserver/powerpc-altivec64l-valgrind.xml
@@ -16,12 +16,17 @@
   <xi:include href="power-fpu.xml"/>
   <xi:include href="power64-linux.xml"/>
   <xi:include href="power-altivec.xml"/>
+  <xi:include href="power-vsx.xml"/>
   <xi:include href="power64-core-valgrind-s1.xml"/>
   <xi:include href="power-fpu-valgrind-s1.xml"/>
+  <xi:include href="power64-core2-valgrind-s1.xml"/>
   <xi:include href="power64-linux-valgrind-s1.xml"/>
   <xi:include href="power-altivec-valgrind-s1.xml"/>
+  <xi:include href="power-vsx-valgrind-s1.xml"/>
   <xi:include href="power64-core-valgrind-s2.xml"/>
   <xi:include href="power-fpu-valgrind-s2.xml"/>
+  <xi:include href="power64-core2-valgrind-s2.xml"/>
   <xi:include href="power64-linux-valgrind-s2.xml"/>
   <xi:include href="power-altivec-valgrind-s2.xml"/>
+  <xi:include href="power-vsx-valgrind-s2.xml"/>
 </target>
diff --git a/coregrind/m_gdbserver/powerpc-altivec64l.xml b/coregrind/m_gdbserver/powerpc-altivec64l.xml
index d06dad9..3fc4fda 100644
--- a/coregrind/m_gdbserver/powerpc-altivec64l.xml
+++ b/coregrind/m_gdbserver/powerpc-altivec64l.xml
@@ -16,4 +16,5 @@
   <xi:include href="power-fpu.xml"/>
   <xi:include href="power64-linux.xml"/>
   <xi:include href="power-altivec.xml"/>
+  <xi:include href="power-vsx.xml"/>
 </target>
diff --git a/coregrind/m_gdbserver/valgrind-low-ppc64.c b/coregrind/m_gdbserver/valgrind-low-ppc64.c
index 3bf90b1..3c6146c 100644
--- a/coregrind/m_gdbserver/valgrind-low-ppc64.c
+++ b/coregrind/m_gdbserver/valgrind-low-ppc64.c
@@ -35,6 +35,51 @@
 
 #include "libvex_guest_ppc64.h"
 
+/* The PPC64 register layout with vs register support (Power 7 and beyond)
+   consists of 64 VSR registers of size 128-bits.  The 32 floating point
+   registers fp map to the upper 64-bits of vsr[0] to vsr[31].  The 32
+   vr[0] to vr[31] registers of size 128-bits map to vsr[31] to vsr[63].  The
+   lower 64-bits of the vsr[0] to vsr[31] registers are in the pseudo
+   registers vs[0]h to vs[31]h registers.  These pseudo registers get printed
+   by GDB but there are no instructions that directly access these registers.
+   When GDB prints the vsr[0] to vsr[31] registers it combines the contents
+   of the floating point registers fp[0] to fp[31] and its corresponding
+   vs[0]h to vs[31]h registers to display the VSR contents.  The vsr[32]
+   to vsr[63] contents are the same as the the vr[0] to vr[31] contents.
+
+   GDB also prints fp[32] to fp[63].  These are simply the upper 64 bits of
+   vsr[32] to vsr[63] however, these are not "real" floating point registers
+   as none of the floating point instructions can access these registers.
+
+    Register map.
+                  MSB          IBM bit numbering           LSB
+                   0                 63 64                127
+         vsr[0]   |        fp[0]       |       vs[0]h        |
+         vsr[1]   |        fp[1]       |       vs[1]h        |
+         vsr[2]   |        fp[2]       |       vs[2]h        |
+          ...
+         vsr[31]  |        fp[31]      |       vs[31]h       |
+         vsr[32]  |                  vr[0]                   |
+         vsr[33]  |                  vr[1]                   |
+          ...
+         vsr[63]  |                  vr[31]                  |
+
+    Note, not shown above are the fake fp[32] to fp[63] that GDB prints
+
+   Valgrind has two shadow registers for each real register denoted with
+   the suffix s1 and s2.   When printing the contents of the shadow registers,
+   GDB does not explicitly print the shadow registers vsr[0] to vsr[63]. GDB
+   prints the shadow register contents of the 32 floating point registers as
+   fp[0]s1 to fp[31]s1 and fp[0]s2 to fp[31]s2.  The shadow register contents
+   of vs[0]hs1 to vs[31]hs1 and vs[0]hs2 to vs[31]hs2 are also printed.  The
+   user needs to construct the vsr[i]s1 shadow register contents by looking
+   at fp[i]s1 for the upper 64-bits and vs[i]hs1 for the lower 64-bits.  The
+   vsr[i]s2 shadow register contents are constructed similarly.
+
+   GDB prints the 128-bit shadow register contents of the 32 vr registers as
+   vr[0]s1 to vr[31]s1 and vr[0]s2 to vr[31]s2. These are also the value of the
+   VSR shadow registers vsr[32]s1 to vsr[63]s1 and vsr[32]s2 to vsr[63]s2. */
+
 static struct reg regs[] = {
   { "r0", 0, 64 },
   { "r1", 64, 64 },
@@ -143,7 +188,40 @@ static struct reg regs[] = {
   { "vr31", 8544, 128 },
   { "vscr", 8672, 32 },
   { "vrsave", 8704, 32 },
+  { "vs0h", 8736, 64 },
+  { "vs1h", 8800, 64 },
+  { "vs2h", 8864, 64 },
+  { "vs3h", 8928, 64 },
+  { "vs4h", 8992, 64 },
+  { "vs5h", 9056, 64 },
+  { "vs6h", 9120, 64 },
+  { "vs7h", 9184, 64 },
+  { "vs8h", 9248, 64 },
+  { "vs9h", 9312, 64 },
+  { "vs10h", 9376, 64 },
+  { "vs11h", 9440, 64 },
+  { "vs12h", 9504, 64 },
+  { "vs13h", 9568, 64 },
+  { "vs14h", 9632, 64 },
+  { "vs15h", 9696, 64 },
+  { "vs16h", 9760, 64 },
+  { "vs17h", 9824, 64 },
+  { "vs18h", 9888, 64 },
+  { "vs19h", 9952, 64 },
+  { "vs20h", 10016, 64 },
+  { "vs21h", 10080, 64 },
+  { "vs22h", 10144, 64 },
+  { "vs23h", 10208, 64 },
+  { "vs24h", 10272, 64 },
+  { "vs25h", 10336, 64 },
+  { "vs26h", 10400, 64 },
+  { "vs27h", 10464, 64 },
+  { "vs28h", 10528, 64 },
+  { "vs29h", 10592, 64 },
+  { "vs30h", 10656, 64 },
+  { "vs31h", 10720, 64 },
 };
+
 static const char *expedite_regs[] = { "r1", "pc", 0 };
 #define num_regs (sizeof (regs) / sizeof (regs[0]))
 
@@ -178,11 +256,42 @@ void transfer_register (ThreadId tid, int abs_regno, void * buf,
    ThreadState* tst = VG_(get_ThreadState)(tid);
    int set = abs_regno / num_regs;
    int regno = abs_regno % num_regs;
+   int low_offset, high_offset;
+
    *mod = False;
 
    VexGuestPPC64State* ppc64 = (VexGuestPPC64State*) get_arch (set, tst);
 
-   switch (regno) { 
+
+#if defined (VG_LITTLEENDIAN)
+   /* Fetch the 64-bits for the VR registers (VSR[32] to VSR[63] stored as
+    * Little Endian. The 128-bit value is stored as an array of four 32-bit
+    * values.  The lower 32-bits are in element 0 in Little Endian format.
+    */
+   low_offset  = 0;
+
+   /* Fetch the upper 64-bits for the floating point register stored as
+    * Little Endian.  The 128-bit value is stored as an array of four 32-bit
+    * values.  The upper 32-bits are in element 3 in Little Endian format.
+    */
+   high_offset = 2;
+#elif defined (VG_BIGENDIAN)
+   /* Fetch the 64-bits for the VR registers (VSR[32] to VSR[63] stored as
+    * Little Endian. The 128-bit value is stored as an array of four 32-bit
+    * values.  The lower 32-bits are in element 3 in Big Endian format.
+    */
+   low_offset  = 2;
+
+   /* Fetch the upper 64-bits for the floating point register stored as
+    * Little Endian.  The 128-bit value is stored as an array of four 32-bit
+    * values.  The upper 32-bits are in element 0 in Big Endian format.
+    */
+   high_offset = 0;
+#else
+#     error "Unknown endianness"
+#endif
+
+   switch (regno) {
    // numbers here have to match the order of regs above
    // Attention: gdb order does not match valgrind order.
    case 0:  VG_(transfer) (&ppc64->guest_GPR0,  buf, dir, size, mod); break;
@@ -217,44 +326,46 @@ void transfer_register (ThreadId tid, int abs_regno, void * buf,
    case 29: VG_(transfer) (&ppc64->guest_GPR29, buf, dir, size, mod); break;
    case 30: VG_(transfer) (&ppc64->guest_GPR30, buf, dir, size, mod); break;
    case 31: VG_(transfer) (&ppc64->guest_GPR31, buf, dir, size, mod); break;
-   case 32: VG_(transfer) (&ppc64->guest_VSR0,  buf, dir, size, mod); break;
-   case 33: VG_(transfer) (&ppc64->guest_VSR1,  buf, dir, size, mod); break;
-   case 34: VG_(transfer) (&ppc64->guest_VSR2,  buf, dir, size, mod); break;
-   case 35: VG_(transfer) (&ppc64->guest_VSR3,  buf, dir, size, mod); break;
-   case 36: VG_(transfer) (&ppc64->guest_VSR4,  buf, dir, size, mod); break;
-   case 37: VG_(transfer) (&ppc64->guest_VSR5,  buf, dir, size, mod); break;
-   case 38: VG_(transfer) (&ppc64->guest_VSR6,  buf, dir, size, mod); break;
-   case 39: VG_(transfer) (&ppc64->guest_VSR7,  buf, dir, size, mod); break;
-   case 40: VG_(transfer) (&ppc64->guest_VSR8,  buf, dir, size, mod); break;
-   case 41: VG_(transfer) (&ppc64->guest_VSR9,  buf, dir, size, mod); break;
-   case 42: VG_(transfer) (&ppc64->guest_VSR10, buf, dir, size, mod); break;
-   case 43: VG_(transfer) (&ppc64->guest_VSR11, buf, dir, size, mod); break;
-   case 44: VG_(transfer) (&ppc64->guest_VSR12, buf, dir, size, mod); break;
-   case 45: VG_(transfer) (&ppc64->guest_VSR13, buf, dir, size, mod); break;
-   case 46: VG_(transfer) (&ppc64->guest_VSR14, buf, dir, size, mod); break;
-   case 47: VG_(transfer) (&ppc64->guest_VSR15, buf, dir, size, mod); break;
-   case 48: VG_(transfer) (&ppc64->guest_VSR16, buf, dir, size, mod); break;
-   case 49: VG_(transfer) (&ppc64->guest_VSR17, buf, dir, size, mod); break;
-   case 50: VG_(transfer) (&ppc64->guest_VSR18, buf, dir, size, mod); break;
-   case 51: VG_(transfer) (&ppc64->guest_VSR19, buf, dir, size, mod); break;
-   case 52: VG_(transfer) (&ppc64->guest_VSR20, buf, dir, size, mod); break;
-   case 53: VG_(transfer) (&ppc64->guest_VSR21, buf, dir, size, mod); break;
-   case 54: VG_(transfer) (&ppc64->guest_VSR22, buf, dir, size, mod); break;
-   case 55: VG_(transfer) (&ppc64->guest_VSR23, buf, dir, size, mod); break;
-   case 56: VG_(transfer) (&ppc64->guest_VSR24, buf, dir, size, mod); break;
-   case 57: VG_(transfer) (&ppc64->guest_VSR25, buf, dir, size, mod); break;
-   case 58: VG_(transfer) (&ppc64->guest_VSR26, buf, dir, size, mod); break;
-   case 59: VG_(transfer) (&ppc64->guest_VSR27, buf, dir, size, mod); break;
-   case 60: VG_(transfer) (&ppc64->guest_VSR28, buf, dir, size, mod); break;
-   case 61: VG_(transfer) (&ppc64->guest_VSR29, buf, dir, size, mod); break;
-   case 62: VG_(transfer) (&ppc64->guest_VSR30, buf, dir, size, mod); break;
-   case 63: VG_(transfer) (&ppc64->guest_VSR31, buf, dir, size, mod); break;
+
+   case 32: VG_(transfer) (&ppc64->guest_VSR0[high_offset],  buf, dir, size, mod); break;
+   case 33: VG_(transfer) (&ppc64->guest_VSR1[high_offset],  buf, dir, size, mod); break;
+   case 34: VG_(transfer) (&ppc64->guest_VSR2[high_offset],  buf, dir, size, mod); break;
+   case 35: VG_(transfer) (&ppc64->guest_VSR3[high_offset],  buf, dir, size, mod); break;
+   case 36: VG_(transfer) (&ppc64->guest_VSR4[high_offset],  buf, dir, size, mod); break;
+   case 37: VG_(transfer) (&ppc64->guest_VSR5[high_offset],  buf, dir, size, mod); break;
+   case 38: VG_(transfer) (&ppc64->guest_VSR6[high_offset],  buf, dir, size, mod); break;
+   case 39: VG_(transfer) (&ppc64->guest_VSR7[high_offset],  buf, dir, size, mod); break;
+   case 40: VG_(transfer) (&ppc64->guest_VSR8[high_offset],  buf, dir, size, mod); break;
+   case 41: VG_(transfer) (&ppc64->guest_VSR9[high_offset],  buf, dir, size, mod); break;
+   case 42: VG_(transfer) (&ppc64->guest_VSR10[high_offset],  buf, dir, size, mod); break;
+   case 43: VG_(transfer) (&ppc64->guest_VSR11[high_offset],  buf, dir, size, mod); break;
+   case 44: VG_(transfer) (&ppc64->guest_VSR12[high_offset],  buf, dir, size, mod); break;
+   case 45: VG_(transfer) (&ppc64->guest_VSR13[high_offset],  buf, dir, size, mod); break;
+   case 46: VG_(transfer) (&ppc64->guest_VSR14[high_offset],  buf, dir, size, mod); break;
+   case 47: VG_(transfer) (&ppc64->guest_VSR15[high_offset],  buf, dir, size, mod); break;
+   case 48: VG_(transfer) (&ppc64->guest_VSR16[high_offset],  buf, dir, size, mod); break;
+   case 49: VG_(transfer) (&ppc64->guest_VSR17[high_offset],  buf, dir, size, mod); break;
+   case 50: VG_(transfer) (&ppc64->guest_VSR18[high_offset],  buf, dir, size, mod); break;
+   case 51: VG_(transfer) (&ppc64->guest_VSR19[high_offset],  buf, dir, size, mod); break;
+   case 52: VG_(transfer) (&ppc64->guest_VSR20[high_offset],  buf, dir, size, mod); break;
+   case 53: VG_(transfer) (&ppc64->guest_VSR21[high_offset],  buf, dir, size, mod); break;
+   case 54: VG_(transfer) (&ppc64->guest_VSR22[high_offset],  buf, dir, size, mod); break;
+   case 55: VG_(transfer) (&ppc64->guest_VSR23[high_offset],  buf, dir, size, mod); break;
+   case 56: VG_(transfer) (&ppc64->guest_VSR24[high_offset],  buf, dir, size, mod); break;
+   case 57: VG_(transfer) (&ppc64->guest_VSR25[high_offset],  buf, dir, size, mod); break;
+   case 58: VG_(transfer) (&ppc64->guest_VSR26[high_offset],  buf, dir, size, mod); break;
+   case 59: VG_(transfer) (&ppc64->guest_VSR27[high_offset],  buf, dir, size, mod); break;
+   case 60: VG_(transfer) (&ppc64->guest_VSR28[high_offset],  buf, dir, size, mod); break;
+   case 61: VG_(transfer) (&ppc64->guest_VSR29[high_offset],  buf, dir, size, mod); break;
+   case 62: VG_(transfer) (&ppc64->guest_VSR30[high_offset],  buf, dir, size, mod); break;
+   case 63: VG_(transfer) (&ppc64->guest_VSR31[high_offset],  buf, dir, size, mod); break;
+
    case 64: VG_(transfer) (&ppc64->guest_CIA,   buf, dir, size, mod); break;
    case 65: *mod = False; break; // VEX does not model Machine State Register
    case 66: {
       UInt cr = LibVEX_GuestPPC64_get_CR (ppc64);
       if (dir == valgrind_to_gdbserver) {
-         VG_(transfer) (&cr, buf, dir, size, mod); 
+         VG_(transfer) (&cr, buf, dir, size, mod);
       } else {
          UInt newcr;
          VG_(transfer) (&newcr, buf, dir, size, mod);
@@ -280,40 +391,79 @@ void transfer_register (ThreadId tid, int abs_regno, void * buf,
    case 70:  VG_(transfer) (&ppc64->guest_FPROUND, buf, dir, size, mod); break;
    case 71:  *mod = False; break; // GDBTD???? VEX { "orig_r3", 4448, 64 },
    case 72:  *mod = False; break; // GDBTD???? VEX { "trap", 4512, 64 },
-   case 73:  VG_(transfer) (&ppc64->guest_VSR32, buf, dir, size, mod); break;
-   case 74:  VG_(transfer) (&ppc64->guest_VSR33, buf, dir, size, mod); break;
-   case 75:  VG_(transfer) (&ppc64->guest_VSR34, buf, dir, size, mod); break;
-   case 76:  VG_(transfer) (&ppc64->guest_VSR35, buf, dir, size, mod); break;
-   case 77:  VG_(transfer) (&ppc64->guest_VSR36, buf, dir, size, mod); break;
-   case 78:  VG_(transfer) (&ppc64->guest_VSR37, buf, dir, size, mod); break;
-   case 79:  VG_(transfer) (&ppc64->guest_VSR38, buf, dir, size, mod); break;
-   case 80:  VG_(transfer) (&ppc64->guest_VSR39, buf, dir, size, mod); break;
-   case 81:  VG_(transfer) (&ppc64->guest_VSR40, buf, dir, size, mod); break;
-   case 82:  VG_(transfer) (&ppc64->guest_VSR41, buf, dir, size, mod); break;
-   case 83:  VG_(transfer) (&ppc64->guest_VSR42, buf, dir, size, mod); break;
-   case 84:  VG_(transfer) (&ppc64->guest_VSR43, buf, dir, size, mod); break;
-   case 85:  VG_(transfer) (&ppc64->guest_VSR44, buf, dir, size, mod); break;
-   case 86:  VG_(transfer) (&ppc64->guest_VSR45, buf, dir, size, mod); break;
-   case 87:  VG_(transfer) (&ppc64->guest_VSR46, buf, dir, size, mod); break;
-   case 88:  VG_(transfer) (&ppc64->guest_VSR47, buf, dir, size, mod); break;
-   case 89:  VG_(transfer) (&ppc64->guest_VSR48, buf, dir, size, mod); break;
-   case 90:  VG_(transfer) (&ppc64->guest_VSR49, buf, dir, size, mod); break;
-   case 91:  VG_(transfer) (&ppc64->guest_VSR50, buf, dir, size, mod); break;
-   case 92:  VG_(transfer) (&ppc64->guest_VSR51, buf, dir, size, mod); break;
-   case 93:  VG_(transfer) (&ppc64->guest_VSR52, buf, dir, size, mod); break;
-   case 94:  VG_(transfer) (&ppc64->guest_VSR53, buf, dir, size, mod); break;
-   case 95:  VG_(transfer) (&ppc64->guest_VSR54, buf, dir, size, mod); break;
-   case 96:  VG_(transfer) (&ppc64->guest_VSR55, buf, dir, size, mod); break;
-   case 97:  VG_(transfer) (&ppc64->guest_VSR56, buf, dir, size, mod); break;
-   case 98:  VG_(transfer) (&ppc64->guest_VSR57, buf, dir, size, mod); break;
-   case 99:  VG_(transfer) (&ppc64->guest_VSR58, buf, dir, size, mod); break;
-   case 100: VG_(transfer) (&ppc64->guest_VSR59, buf, dir, size, mod); break;
-   case 101: VG_(transfer) (&ppc64->guest_VSR60, buf, dir, size, mod); break;
-   case 102: VG_(transfer) (&ppc64->guest_VSR61, buf, dir, size, mod); break;
-   case 103: VG_(transfer) (&ppc64->guest_VSR62, buf, dir, size, mod); break;
-   case 104: VG_(transfer) (&ppc64->guest_VSR63, buf, dir, size, mod); break;
-   case 105: VG_(transfer) (&ppc64->guest_VSCR, buf, dir, size, mod); break;
+
+   case 73:  VG_(transfer) (&ppc64->guest_VSR32,  buf, dir, size, mod);  break;
+   case 74:  VG_(transfer) (&ppc64->guest_VSR33,  buf, dir, size, mod);  break;
+   case 75:  VG_(transfer) (&ppc64->guest_VSR34,  buf, dir, size, mod);  break;
+   case 76:  VG_(transfer) (&ppc64->guest_VSR35,  buf, dir, size, mod);  break;
+   case 77:  VG_(transfer) (&ppc64->guest_VSR36,  buf, dir, size, mod);  break;
+   case 78:  VG_(transfer) (&ppc64->guest_VSR37,  buf, dir, size, mod);  break;
+   case 79:  VG_(transfer) (&ppc64->guest_VSR38,  buf, dir, size, mod);  break;
+   case 80:  VG_(transfer) (&ppc64->guest_VSR39,  buf, dir, size, mod);  break;
+   case 81:  VG_(transfer) (&ppc64->guest_VSR40,  buf, dir, size, mod);  break;
+   case 82:  VG_(transfer) (&ppc64->guest_VSR40,  buf, dir, size, mod);  break;
+   case 83:  VG_(transfer) (&ppc64->guest_VSR42,  buf, dir, size, mod); break;
+   case 84:  VG_(transfer) (&ppc64->guest_VSR43,  buf, dir, size, mod); break;
+   case 85:  VG_(transfer) (&ppc64->guest_VSR44,  buf, dir, size, mod); break;
+   case 86:  VG_(transfer) (&ppc64->guest_VSR45,  buf, dir, size, mod); break;
+   case 87:  VG_(transfer) (&ppc64->guest_VSR46,  buf, dir, size, mod); break;
+   case 88:  VG_(transfer) (&ppc64->guest_VSR47,  buf, dir, size, mod); break;
+   case 89:  VG_(transfer) (&ppc64->guest_VSR48,  buf, dir, size, mod); break;
+   case 90:  VG_(transfer) (&ppc64->guest_VSR49,  buf, dir, size, mod); break;
+   case 91:  VG_(transfer) (&ppc64->guest_VSR50,  buf, dir, size, mod); break;
+   case 92:  VG_(transfer) (&ppc64->guest_VSR51,  buf, dir, size, mod); break;
+   case 93:  VG_(transfer) (&ppc64->guest_VSR52,  buf, dir, size, mod); break;
+   case 94:  VG_(transfer) (&ppc64->guest_VSR53,  buf, dir, size, mod); break;
+   case 95:  VG_(transfer) (&ppc64->guest_VSR54,  buf, dir, size, mod); break;
+   case 96:  VG_(transfer) (&ppc64->guest_VSR55,  buf, dir, size, mod); break;
+   case 97:  VG_(transfer) (&ppc64->guest_VSR56,  buf, dir, size, mod); break;
+   case 98:  VG_(transfer) (&ppc64->guest_VSR57,  buf, dir, size, mod); break;
+   case 99:  VG_(transfer) (&ppc64->guest_VSR58,  buf, dir, size, mod); break;
+   case 100: VG_(transfer) (&ppc64->guest_VSR59,  buf, dir, size, mod); break;
+   case 101: VG_(transfer) (&ppc64->guest_VSR60,  buf, dir, size, mod); break;
+   case 102: VG_(transfer) (&ppc64->guest_VSR61,  buf, dir, size, mod); break;
+   case 103: VG_(transfer) (&ppc64->guest_VSR62,  buf, dir, size, mod); break;
+   case 104: VG_(transfer) (&ppc64->guest_VSR63,  buf, dir, size, mod); break;
+   case 105: VG_(transfer) (&ppc64->guest_VSCR, buf, dir, size, mod);   break;
    case 106: VG_(transfer) (&ppc64->guest_VRSAVE, buf, dir, size, mod); break;
+
+   /* Fetch the lower 64-bits of the VSR registers.  GDB will combine the
+    * lower 64-bits of the VSR with the upper 64-bits it got fetching the
+    * corresponding floating point register to display the full 128-bit
+    * VSR value.
+    */
+   case 107:  VG_(transfer) (&ppc64->guest_VSR0[low_offset], buf, dir, size, mod); break;
+   case 108:  VG_(transfer) (&ppc64->guest_VSR1[low_offset], buf, dir, size, mod); break;
+   case 109:  VG_(transfer) (&ppc64->guest_VSR2[low_offset], buf, dir, size, mod); break;
+   case 110:  VG_(transfer) (&ppc64->guest_VSR3[low_offset], buf, dir, size, mod); break;
+   case 111:  VG_(transfer) (&ppc64->guest_VSR4[low_offset], buf, dir, size, mod); break;
+   case 112:  VG_(transfer) (&ppc64->guest_VSR5[low_offset], buf, dir, size, mod); break;
+   case 113:  VG_(transfer) (&ppc64->guest_VSR6[low_offset], buf, dir, size, mod); break;
+   case 114:  VG_(transfer) (&ppc64->guest_VSR7[low_offset], buf, dir, size, mod); break;
+   case 115:  VG_(transfer) (&ppc64->guest_VSR8[low_offset], buf, dir, size, mod); break;
+   case 116:  VG_(transfer) (&ppc64->guest_VSR9[low_offset], buf, dir, size, mod); break;
+   case 117:  VG_(transfer) (&ppc64->guest_VSR10[low_offset], buf, dir, size, mod); break;
+   case 118:  VG_(transfer) (&ppc64->guest_VSR11[low_offset], buf, dir, size, mod); break;
+   case 119:  VG_(transfer) (&ppc64->guest_VSR12[low_offset], buf, dir, size, mod); break;
+   case 120:  VG_(transfer) (&ppc64->guest_VSR13[low_offset], buf, dir, size, mod); break;
+   case 121:  VG_(transfer) (&ppc64->guest_VSR14[low_offset], buf, dir, size, mod); break;
+   case 122:  VG_(transfer) (&ppc64->guest_VSR15[low_offset], buf, dir, size, mod); break;
+   case 123:  VG_(transfer) (&ppc64->guest_VSR16[low_offset], buf, dir, size, mod); break;
+   case 124:  VG_(transfer) (&ppc64->guest_VSR17[low_offset], buf, dir, size, mod); break;
+   case 125:  VG_(transfer) (&ppc64->guest_VSR18[low_offset], buf, dir, size, mod); break;
+   case 126:  VG_(transfer) (&ppc64->guest_VSR19[low_offset], buf, dir, size, mod); break;
+   case 127:  VG_(transfer) (&ppc64->guest_VSR20[low_offset], buf, dir, size, mod); break;
+   case 128:  VG_(transfer) (&ppc64->guest_VSR21[low_offset], buf, dir, size, mod); break;
+   case 129:  VG_(transfer) (&ppc64->guest_VSR22[low_offset], buf, dir, size, mod); break;
+   case 130:  VG_(transfer) (&ppc64->guest_VSR23[low_offset], buf, dir, size, mod); break;
+   case 131:  VG_(transfer) (&ppc64->guest_VSR24[low_offset], buf, dir, size, mod); break;
+   case 132:  VG_(transfer) (&ppc64->guest_VSR25[low_offset], buf, dir, size, mod); break;
+   case 133:  VG_(transfer) (&ppc64->guest_VSR26[low_offset], buf, dir, size, mod); break;
+   case 134:  VG_(transfer) (&ppc64->guest_VSR27[low_offset], buf, dir, size, mod); break;
+   case 135:  VG_(transfer) (&ppc64->guest_VSR28[low_offset], buf, dir, size, mod); break;
+   case 136:  VG_(transfer) (&ppc64->guest_VSR29[low_offset], buf, dir, size, mod); break;
+   case 137:  VG_(transfer) (&ppc64->guest_VSR30[low_offset], buf, dir, size, mod); break;
+   case 138:  VG_(transfer) (&ppc64->guest_VSR31[low_offset], buf, dir, size, mod); break;
    default: vg_assert(0);
    }
 }
@@ -321,6 +471,14 @@ void transfer_register (ThreadId tid, int abs_regno, void * buf,
 static
 const char* target_xml (Bool shadow_mode)
 {
+   /* NOTE, the current powerpc-altivec64l*.xml files includes the vsx
+    * registers.  Power 6 and earlier power processors do not support the
+    * vsx registers.  GDB has a bug in that it is only checking for ptrace
+    * support rather then checking the actual HW feature.  Hence GDB on
+    * power 6 prints vsx registers that do not exist.  Valgrind GDB support
+    * also has to include the vsx register definitions to be consistent with
+    * GDB.
+    */
    if (shadow_mode) {
       return "powerpc-altivec64l-valgrind.xml";
    } else {

commit 323a91bfd7dd10d52c77ff31ae6d6b8d0bb37f32
Author: carll <carll@a5019735-40e9-0310-863c-91ae7b9d1cf9>
Date:   Fri Apr 22 15:03:46 2016 +0000

    PPC64, Valgrind with GDB does not display 64-bit and 128-bit registers
    correctly
    
    Forgot to add the new files to the previous commit 15864.
    
    coregrind/m_gdbserver/power64-core2-valgrind-s1.xml
    coregrind/m_gdbserver/power64-core2-valgrind-s2.xml
    coregrind/m_gdbserver/power-vsx-valgrind-s1.xml
    coregrind/m_gdbserver/power-vsx-valgrind-s2.xml
    coregrind/m_gdbserver/power-vsx.xml
    
    Bugzilla 360008 was opened for this issue.
    
    git-svn-id: svn://svn.valgrind.org/valgrind/trunk@15866 a5019735-40e9-0310-863c-91ae7b9d1cf9

diff --git a/coregrind/m_gdbserver/power-vsx-valgrind-s1.xml b/coregrind/m_gdbserver/power-vsx-valgrind-s1.xml
new file mode 100644
index 0000000..24730ff
--- /dev/null
+++ b/coregrind/m_gdbserver/power-vsx-valgrind-s1.xml
@@ -0,0 +1,44 @@
+<?xml version="1.0"?>
+<!-- Copyright (C) 2008-2016 Free Software Foundation, Inc.
+
+     Copying and distribution of this file, with or without modification,
+     are permitted in any medium without royalty provided the copyright
+     notice and this notice are preserved.  -->
+
+<!-- POWER7 VSX registers that do not overlap existing FP and VMX
+     registers.  -->
+<!DOCTYPE feature SYSTEM "gdb-target.dtd">
+<feature name="org.gnu.gdb.power.vsx">
+  <reg name="vs0hs1" bitsize="64" type="uint64"/>
+  <reg name="vs1hs1" bitsize="64" type="uint64"/>
+  <reg name="vs2hs1" bitsize="64" type="uint64"/>
+  <reg name="vs3hs1" bitsize="64" type="uint64"/>
+  <reg name="vs4hs1" bitsize="64" type="uint64"/>
+  <reg name="vs5hs1" bitsize="64" type="uint64"/>
+  <reg name="vs6hs1" bitsize="64" type="uint64"/>
+  <reg name="vs7hs1" bitsize="64" type="uint64"/>
+  <reg name="vs8hs1" bitsize="64" type="uint64"/>
+  <reg name="vs9hs1" bitsize="64" type="uint64"/>
+  <reg name="vs10hs1" bitsize="64" type="uint64"/>
+  <reg name="vs11hs1" bitsize="64" type="uint64"/>
+  <reg name="vs12hs1" bitsize="64" type="uint64"/>
+  <reg name="vs13hs1" bitsize="64" type="uint64"/>
+  <reg name="vs14hs1" bitsize="64" type="uint64"/>
+  <reg name="vs15hs1" bitsize="64" type="uint64"/>
+  <reg name="vs16hs1" bitsize="64" type="uint64"/>
+  <reg name="vs17hs1" bitsize="64" type="uint64"/>
+  <reg name="vs18hs1" bitsize="64" type="uint64"/>
+  <reg name="vs19hs1" bitsize="64" type="uint64"/>
+  <reg name="vs20hs1" bitsize="64" type="uint64"/>
+  <reg name="vs21hs1" bitsize="64" type="uint64"/>
+  <reg name="vs22hs1" bitsize="64" type="uint64"/>
+  <reg name="vs23hs1" bitsize="64" type="uint64"/>
+  <reg name="vs24hs1" bitsize="64" type="uint64"/>
+  <reg name="vs25hs1" bitsize="64" type="uint64"/>
+  <reg name="vs26hs1" bitsize="64" type="uint64"/>
+  <reg name="vs27hs1" bitsize="64" type="uint64"/>
+  <reg name="vs28hs1" bitsize="64" type="uint64"/>
+  <reg name="vs29hs1" bitsize="64" type="uint64"/>
+  <reg name="vs30hs1" bitsize="64" type="uint64"/>
+  <reg name="vs31hs1" bitsize="64" type="uint64"/>
+</feature>
diff --git a/coregrind/m_gdbserver/power-vsx-valgrind-s2.xml b/coregrind/m_gdbserver/power-vsx-valgrind-s2.xml
new file mode 100644
index 0000000..8854e8f
--- /dev/null
+++ b/coregrind/m_gdbserver/power-vsx-valgrind-s2.xml
@@ -0,0 +1,44 @@
+<?xml version="1.0"?>
+<!-- Copyright (C) 2008-2016 Free Software Foundation, Inc.
+
+     Copying and distribution of this file, with or without modification,
+     are permitted in any medium without royalty provided the copyright
+     notice and this notice are preserved.  -->
+
+<!-- POWER7 VSX registers that do not overlap existing FP and VMX
+     registers.  -->
+<!DOCTYPE feature SYSTEM "gdb-target.dtd">
+<feature name="org.gnu.gdb.power.vsx">
+  <reg name="vs0hs2" bitsize="64" type="uint64"/>
+  <reg name="vs1hs2" bitsize="64" type="uint64"/>
+  <reg name="vs2hs2" bitsize="64" type="uint64"/>
+  <reg name="vs3hs2" bitsize="64" type="uint64"/>
+  <reg name="vs4hs2" bitsize="64" type="uint64"/>
+  <reg name="vs5hs2" bitsize="64" type="uint64"/>
+  <reg name="vs6hs2" bitsize="64" type="uint64"/>
+  <reg name="vs7hs2" bitsize="64" type="uint64"/>
+  <reg name="vs8hs2" bitsize="64" type="uint64"/>
+  <reg name="vs9hs2" bitsize="64" type="uint64"/>
+  <reg name="vs10hs2" bitsize="64" type="uint64"/>
+  <reg name="vs11hs2" bitsize="64" type="uint64"/>
+  <reg name="vs12hs2" bitsize="64" type="uint64"/>
+  <reg name="vs13hs2" bitsize="64" type="uint64"/>
+  <reg name="vs14hs2" bitsize="64" type="uint64"/>
+  <reg name="vs15hs2" bitsize="64" type="uint64"/>
+  <reg name="vs16hs2" bitsize="64" type="uint64"/>
+  <reg name="vs17hs2" bitsize="64" type="uint64"/>
+  <reg name="vs18hs2" bitsize="64" type="uint64"/>
+  <reg name="vs19hs2" bitsize="64" type="uint64"/>
+  <reg name="vs20hs2" bitsize="64" type="uint64"/>
+  <reg name="vs21hs2" bitsize="64" type="uint64"/>
+  <reg name="vs22hs2" bitsize="64" type="uint64"/>
+  <reg name="vs23hs2" bitsize="64" type="uint64"/>
+  <reg name="vs24hs2" bitsize="64" type="uint64"/>
+  <reg name="vs25hs2" bitsize="64" type="uint64"/>
+  <reg name="vs26hs2" bitsize="64" type="uint64"/>
+  <reg name="vs27hs2" bitsize="64" type="uint64"/>
+  <reg name="vs28hs2" bitsize="64" type="uint64"/>
+  <reg name="vs29hs2" bitsize="64" type="uint64"/>
+  <reg name="vs30hs2" bitsize="64" type="uint64"/>
+  <reg name="vs31hs2" bitsize="64" type="uint64"/>
+</feature>
diff --git a/coregrind/m_gdbserver/power-vsx.xml b/coregrind/m_gdbserver/power-vsx.xml
new file mode 100644
index 0000000..411e35c
--- /dev/null
+++ b/coregrind/m_gdbserver/power-vsx.xml
@@ -0,0 +1,44 @@
+<?xml version="1.0"?>
+<!-- Copyright (C) 2008-2016 Free Software Foundation, Inc.
+
+     Copying and distribution of this file, with or without modification,
+     are permitted in any medium without royalty provided the copyright
+     notice and this notice are preserved.  -->
+
+<!-- POWER7 VSX registers that do not overlap existing FP and VMX
+     registers.  -->
+<!DOCTYPE feature SYSTEM "gdb-target.dtd">
+<feature name="org.gnu.gdb.power.vsx">
+  <reg name="vs0h" bitsize="64" type="uint64" regnum="107"/>
+  <reg name="vs1h" bitsize="64" type="uint64"/>
+  <reg name="vs2h" bitsize="64" type="uint64"/>
+  <reg name="vs3h" bitsize="64" type="uint64"/>
+  <reg name="vs4h" bitsize="64" type="uint64"/>
+  <reg name="vs5h" bitsize="64" type="uint64"/>
+  <reg name="vs6h" bitsize="64" type="uint64"/>
+  <reg name="vs7h" bitsize="64" type="uint64"/>
+  <reg name="vs8h" bitsize="64" type="uint64"/>
+  <reg name="vs9h" bitsize="64" type="uint64"/>
+  <reg name="vs10h" bitsize="64" type="uint64"/>
+  <reg name="vs11h" bitsize="64" type="uint64"/>
+  <reg name="vs12h" bitsize="64" type="uint64"/>
+  <reg name="vs13h" bitsize="64" type="uint64"/>
+  <reg name="vs14h" bitsize="64" type="uint64"/>
+  <reg name="vs15h" bitsize="64" type="uint64"/>
+  <reg name="vs16h" bitsize="64" type="uint64"/>
+  <reg name="vs17h" bitsize="64" type="uint64"/>
+  <reg name="vs18h" bitsize="64" type="uint64"/>
+  <reg name="vs19h" bitsize="64" type="uint64"/>
+  <reg name="vs20h" bitsize="64" type="uint64"/>
+  <reg name="vs21h" bitsize="64" type="uint64"/>
+  <reg name="vs22h" bitsize="64" type="uint64"/>
+  <reg name="vs23h" bitsize="64" type="uint64"/>
+  <reg name="vs24h" bitsize="64" type="uint64"/>
+  <reg name="vs25h" bitsize="64" type="uint64"/>
+  <reg name="vs26h" bitsize="64" type="uint64"/>
+  <reg name="vs27h" bitsize="64" type="uint64"/>
+  <reg name="vs28h" bitsize="64" type="uint64"/>
+  <reg name="vs29h" bitsize="64" type="uint64"/>
+  <reg name="vs30h" bitsize="64" type="uint64"/>
+  <reg name="vs31h" bitsize="64" type="uint64"/>
+</feature>
diff --git a/coregrind/m_gdbserver/power64-core2-valgrind-s1.xml b/coregrind/m_gdbserver/power64-core2-valgrind-s1.xml
new file mode 100644
index 0000000..1012a2d
--- /dev/null
+++ b/coregrind/m_gdbserver/power64-core2-valgrind-s1.xml
@@ -0,0 +1,16 @@
+<?xml version="1.0"?>
+<!-- Copyright (C) 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
+
+     Copying and distribution of this file, with or without modification,
+     are permitted in any medium without royalty provided the copyright
+     notice and this notice are preserved.  -->
+
+<!DOCTYPE feature SYSTEM "gdb-target.dtd">
+<feature name="org.gnu.gdb.power.core2-valgrind-s1">
+  <reg name="pcs1" bitsize="64" type="code_ptr"/>
+  <reg name="msrs1" bitsize="64" type="uint64"/>
+  <reg name="crs1" bitsize="32" type="uint32"/>
+  <reg name="lrs1" bitsize="64" type="code_ptr"/>
+  <reg name="ctrs1" bitsize="64" type="uint64"/>
+  <reg name="xers1" bitsize="32" type="uint32"/>
+</feature>
diff --git a/coregrind/m_gdbserver/power64-core2-valgrind-s2.xml b/coregrind/m_gdbserver/power64-core2-valgrind-s2.xml
new file mode 100644
index 0000000..fa50bd4
--- /dev/null
+++ b/coregrind/m_gdbserver/power64-core2-valgrind-s2.xml
@@ -0,0 +1,16 @@
+<?xml version="1.0"?>
+<!-- Copyright (C) 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
+
+     Copying and distribution of this file, with or without modification,
+     are permitted in any medium without royalty provided the copyright
+     notice and this notice are preserved.  -->
+
+<!DOCTYPE feature SYSTEM "gdb-target.dtd">
+<feature name="org.gnu.gdb.power.core2-valgrind-s2">
+  <reg name="pcs2" bitsize="64" type="code_ptr"/>
+  <reg name="msrs2" bitsize="64" type="uint64"/>
+  <reg name="crs2" bitsize="32" type="uint32"/>
+  <reg name="lrs2" bitsize="64" type="code_ptr"/>
+  <reg name="ctrs2" bitsize="64" type="uint64"/>
+  <reg name="xers2" bitsize="32" type="uint32"/>
+</feature>
Only in valgrind-3.11.0: autom4te.cache
diff -ur valgrind-3.11.0.orig/coregrind/Makefile.in valgrind-3.11.0/coregrind/Makefile.in
--- valgrind-3.11.0.orig/coregrind/Makefile.in	2016-04-29 15:07:46.688655051 +0200
+++ valgrind-3.11.0/coregrind/Makefile.in	2016-04-29 15:11:24.219880810 +0200
@@ -1746,12 +1746,17 @@
 	m_gdbserver/power64-core-valgrind-s1.xml \
 	m_gdbserver/power64-core-valgrind-s2.xml \
 	m_gdbserver/power64-core.xml \
+	m_gdbserver/power64-core2-valgrind-s1.xml \
+	m_gdbserver/power64-core2-valgrind-s2.xml \
 	m_gdbserver/power64-linux-valgrind-s1.xml \
 	m_gdbserver/power64-linux-valgrind-s2.xml \
 	m_gdbserver/power64-linux.xml \
 	m_gdbserver/power-altivec-valgrind-s1.xml \
 	m_gdbserver/power-altivec-valgrind-s2.xml \
 	m_gdbserver/power-altivec.xml \
+	m_gdbserver/power-vsx-valgrind-s1.xml \
+	m_gdbserver/power-vsx-valgrind-s2.xml \
+	m_gdbserver/power-vsx.xml \
 	m_gdbserver/power-core-valgrind-s1.xml \
 	m_gdbserver/power-core-valgrind-s2.xml \
 	m_gdbserver/power-core.xml \

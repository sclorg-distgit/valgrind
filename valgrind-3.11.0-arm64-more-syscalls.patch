From fe31b9a6fe9aad1a83c996032717f4757ff21f75 Mon Sep 17 00:00:00 2001
From: mjw <mjw@a5019735-40e9-0310-863c-91ae7b9d1cf9>
Date: Wed, 9 Mar 2016 16:18:34 +0000
Subject: [PATCH 1/3] Use correct syscall numbers on arm64. Fix rename, dup2
 and getpgrp.

We were using some wrong syscall numbers in vki-scnums-arm64-linux.h
arm64 doesn't implement a couple of old deprecated system calls like
rename, dup2, getpgrp and fork. Adjust m_libcfile.c rename and dup2
functions to use renameat (also on tilegx) and dup3 (with fcntl fallback
for bad oldfd). And in m_libcproc.c implement getpgrp as getpgid(0).
Also don't compile the fork syswrap on arm64 (it only supports clone).

In practice this only affected callgrind which was unable to rename
dump files in some cases and ELF core dumps might have contained some
bogus prstatus fields.

Related to bug #359503 - Add missing syscalls for aarch64 (arm64)
Reported by Marcin Juszkiewicz who also posted a nice overview
of system calls on different linux architectures:
https://marcin.juszkiewicz.com.pl/2016/03/05/from-a-diary-of-aarch64-porter-system-calls/

git-svn-id: svn://svn.valgrind.org/valgrind/trunk@15824 a5019735-40e9-0310-863c-91ae7b9d1cf9
---
 coregrind/m_libcfile.c                | 23 ++++++++++++++-------
 coregrind/m_libcproc.c                |  4 +++-
 coregrind/m_syswrap/syswrap-generic.c |  4 ++--
 include/vki/vki-scnums-arm64-linux.h  | 38 +++++++++++++++++------------------
 4 files changed, 40 insertions(+), 29 deletions(-)

diff --git a/coregrind/m_libcfile.c b/coregrind/m_libcfile.c
index 7e94ce3..c413db1 100644
--- a/coregrind/m_libcfile.c
+++ b/coregrind/m_libcfile.c
@@ -480,7 +480,18 @@ SysRes VG_(dup) ( Int oldfd )
 
 SysRes VG_(dup2) ( Int oldfd, Int newfd )
 {
-#  if defined(VGO_linux) || defined(VGO_darwin)
+#  if defined(VGP_arm64_linux)
+   /* We only have dup3, that means we have to mimic dup2.
+      The only real difference is when oldfd == newfd.
+      dup3 always returns an error, but dup2 returns only an
+      error if the fd is invalid, otherwise it returns newfd. */
+   if (oldfd == newfd) {
+      if (VG_(fcntl)(oldfd, VKI_F_GETFL, 0) == -1)
+         return VG_(mk_SysRes_Error)(VKI_EBADF);
+      return VG_(mk_SysRes_Success)(newfd);
+   }
+   return VG_(do_syscall3)(__NR_dup3, oldfd, newfd, 0);
+#  elif defined(VGO_linux) || defined(VGO_darwin)
    return VG_(do_syscall2)(__NR_dup2, oldfd, newfd);
 #  elif defined(VGO_solaris)
    return VG_(do_syscall3)(__NR_fcntl, oldfd, F_DUP2FD, newfd);
@@ -504,14 +515,12 @@ Int VG_(fcntl) ( Int fd, Int cmd, Addr arg )
 
 Int VG_(rename) ( const HChar* old_name, const HChar* new_name )
 {
-#  if defined(VGP_tilegx_linux)
-   SysRes res = VG_(do_syscall3)(__NR_renameat, VKI_AT_FDCWD,
-                                 (UWord)old_name, (UWord)new_name);
-#  elif defined(VGO_linux) || defined(VGO_darwin)
-   SysRes res = VG_(do_syscall2)(__NR_rename, (UWord)old_name, (UWord)new_name);
-#  elif defined(VGO_solaris)
+#  if defined(VGO_solaris) \
+      || defined(VGP_arm64_linux) || defined(VGP_tilegx_linux)
    SysRes res = VG_(do_syscall4)(__NR_renameat, VKI_AT_FDCWD, (UWord)old_name,
                                  VKI_AT_FDCWD, (UWord)new_name);
+#  elif defined(VGO_linux) || defined(VGO_darwin)
+   SysRes res = VG_(do_syscall2)(__NR_rename, (UWord)old_name, (UWord)new_name);
 #  else
 #    error "Unknown OS"
 #  endif
diff --git a/coregrind/m_libcproc.c b/coregrind/m_libcproc.c
index a30f7dc..eb911be 100644
--- a/coregrind/m_libcproc.c
+++ b/coregrind/m_libcproc.c
@@ -708,7 +708,9 @@ Int VG_(getpid) ( void )
 Int VG_(getpgrp) ( void )
 {
    /* ASSUMES SYSCALL ALWAYS SUCCEEDS */
-#  if defined(VGO_linux) || defined(VGO_darwin)
+#  if defined(VGP_arm64_linux)
+   return sr_Res( VG_(do_syscall1)(__NR_getpgid, 0) );
+#  elif defined(VGO_linux) || defined(VGO_darwin)
    return sr_Res( VG_(do_syscall0)(__NR_getpgrp) );
 #  elif defined(VGO_solaris)
    /* Uses the shared pgrpsys syscall, 0 for the getpgrp variant. */
diff --git a/coregrind/m_syswrap/syswrap-generic.c b/coregrind/m_syswrap/syswrap-generic.c
index 2eaf505..dd1da9c 100644
--- a/coregrind/m_syswrap/syswrap-generic.c
+++ b/coregrind/m_syswrap/syswrap-generic.c
@@ -3264,7 +3264,7 @@ POST(sys_newfstat)
    POST_MEM_WRITE( ARG2, sizeof(struct vki_stat) );
 }
 
-#if !defined(VGO_solaris)
+#if !defined(VGO_solaris) && !defined(VGP_arm64_linux)
 static vki_sigset_t fork_saved_mask;
 
 // In Linux, the sys_fork() function varies across architectures, but we
@@ -3327,7 +3327,7 @@ PRE(sys_fork)
       VG_(sigprocmask)(VKI_SIG_SETMASK, &fork_saved_mask, NULL);
    }
 }
-#endif // !defined(VGO_solaris)
+#endif // !defined(VGO_solaris) && !defined(VGP_arm64_linux)
 
 PRE(sys_ftruncate)
 {
diff --git a/include/vki/vki-scnums-arm64-linux.h b/include/vki/vki-scnums-arm64-linux.h
index f70a2ed..e963c45 100644
--- a/include/vki/vki-scnums-arm64-linux.h
+++ b/include/vki/vki-scnums-arm64-linux.h
@@ -331,7 +331,7 @@
 //#define __NR_link 1025
 //__SYSCALL(__NR_link, sys_link)
 //#define __NR_unlink 1026
-#define __NR_mknod 1027
+//#define __NR_mknod 1027
 //#define __NR_chmod 1028
 //__SYSCALL(__NR_chmod, sys_chmod)
 //#define __NR_chown 1029
@@ -342,8 +342,8 @@
 //__SYSCALL(__NR_rmdir, sys_rmdir)
 //#define __NR_lchown 1032
 //__SYSCALL(__NR_lchown, sys_lchown)
-#define __NR_access 1033
-#define __NR_rename 1034
+//#define __NR_access 1033
+//#define __NR_rename 1034
 //#define __NR_readlink 1035
 //#define __NR_symlink 1036
 //__SYSCALL(__NR_symlink, sys_symlink)
@@ -359,8 +359,8 @@
 //#endif /* __ARCH_WANT_SYSCALL_NO_AT */
 //
 //#ifdef __ARCH_WANT_SYSCALL_NO_FLAGS
-#define __NR_pipe 1040
-#define __NR_dup2 1041
+//#define __NR_pipe 1040
+//#define __NR_dup2 1041
 //#define __NR_epoll_create 1042
 //__SYSCALL(__NR_epoll_create, sys_epoll_create)
 //#define __NR_inotify_init 1043
@@ -383,7 +383,7 @@
 //__SYSCALL(__NR_ftruncate, sys_ftruncate)
 //#define __NR_truncate 1048
 //__SYSCALL(__NR_truncate, sys_truncate)
-#define __NR_stat 1049
+//#define __NR_stat 1049
 //#define __NR_lstat 1050
 //__SYSCALL(__NR_lstat, sys_newlstat)
 //ZZ#define __NR_fstat 1051
@@ -399,7 +399,7 @@
 //#define __NR_statfs 1056
 //__SYSCALL(__NR_statfs, sys_statfs)
 //#define __NR_lseek 1057
-#define __NR_mmap 1058
+//#define __NR_mmap 1058
 //
 //#undef __NR_syscalls
 //#define __NR_syscalls (__NR_mmap+1)
@@ -409,7 +409,7 @@
 //#define __NR_alarm 1059
 //#define __ARCH_WANT_SYS_ALARM
 //__SYSCALL(__NR_alarm, sys_alarm)
-#define __NR_getpgrp 1060
+//#define __NR_getpgrp 1060
 //#define __ARCH_WANT_SYS_GETPGRP
 //__SYSCALL(__NR_getpgrp, sys_getpgrp)
 //#define __NR_pause 1061
@@ -425,13 +425,13 @@
 //
 //#define __NR_creat 1064
 //__SYSCALL(__NR_creat, sys_creat)
-#define __NR_getdents 1065
+//#define __NR_getdents 1065
 //#define __NR_futimesat 1066
 //__SYSCALL(__NR_futimesat, sys_futimesat)
 //#define __NR_select 1067
 //#define __ARCH_WANT_SYS_SELECT
 //__SYSCALL(__NR_select, sys_select)
-#define __NR_poll 1068
+//#define __NR_poll 1068
 //#define __NR_epoll_wait 1069
 //__SYSCALL(__NR_epoll_wait, sys_epoll_wait)
 //#define __NR_ustat 1070
@@ -454,7 +454,7 @@
 //#define __NR__sysctl 1078
 //__SYSCALL(__NR__sysctl, sys_sysctl)
 //
-#define __NR_fork 1079
+//#define __NR_fork 1079
 //#ifdef CONFIG_MMU
 //__SYSCALL(__NR_fork, sys_fork)
 //#else
@@ -478,16 +478,16 @@
 // */
 //#if __BITS_PER_LONG == 64 && !defined(__SYSCALL_COMPAT)
 #define __NR_fcntl __NR3264_fcntl
-//#define __NR_statfs __NR3264_statfs
-//#define __NR_fstatfs __NR3264_fstatfs
-//#define __NR_truncate __NR3264_truncate
-//#define __NR_ftruncate __NR3264_ftruncate
+#define __NR_statfs __NR3264_statfs
+#define __NR_fstatfs __NR3264_fstatfs
+#define __NR_truncate __NR3264_truncate
+#define __NR_ftruncate __NR3264_ftruncate
 #define __NR_lseek __NR3264_lseek
-//#define __NR_sendfile __NR3264_sendfile
-//#define __NR_newfstatat __NR3264_fstatat
+#define __NR_sendfile __NR3264_sendfile
+#define __NR_newfstatat __NR3264_fstatat
 #define __NR_fstat __NR3264_fstat
-//#define __NR_mmap __NR3264_mmap
-//#define __NR_fadvise64 __NR3264_fadvise64
+#define __NR_mmap __NR3264_mmap
+#define __NR_fadvise64 __NR3264_fadvise64
 //#ifdef __NR3264_stat
 //#define __NR_stat __NR3264_stat
 //#define __NR_lstat __NR3264_lstat
-- 
2.5.0

From a4070ecdf2b2ade10ccf77518e97cc8a8280fd34 Mon Sep 17 00:00:00 2001
From: mjw <mjw@a5019735-40e9-0310-863c-91ae7b9d1cf9>
Date: Wed, 9 Mar 2016 16:18:36 +0000
Subject: [PATCH 2/3] Add arm64 scalar test. Enable tested syscalls.

The new memcheck/tests/arm64-linux/scalar test is based on the
memcheck/tests/x86-linux/scalar test and contains all syscalls
that are also available on arm64. To make comparison of exp results
easier the order of the tested syscalls is the same as on x86.
This enables a couple extra arm64 syscalls. Part of the fix for
bug #359503 - Add missing syscalls for aarch64 (arm64).

git-svn-id: svn://svn.valgrind.org/valgrind/trunk@15825 a5019735-40e9-0310-863c-91ae7b9d1cf9
---
 configure.ac                                 |    1 +
 coregrind/m_syswrap/syswrap-arm64-linux.c    |  127 +-
 coregrind/m_syswrap/syswrap-linux.c          |    2 +-
 memcheck/tests/Makefile.am                   |    6 +-
 memcheck/tests/arm64-linux/Makefile.am       |   19 +
 memcheck/tests/arm64-linux/filter_stderr     |    3 +
 memcheck/tests/arm64-linux/scalar.c          | 1278 +++++++++++++
 memcheck/tests/arm64-linux/scalar.h          |   62 +
 memcheck/tests/arm64-linux/scalar.stderr.exp | 2598 ++++++++++++++++++++++++++
 memcheck/tests/arm64-linux/scalar.vgtest     |    3 +
 10 files changed, 4033 insertions(+), 66 deletions(-)
 create mode 100644 memcheck/tests/arm64-linux/Makefile.am
 create mode 100755 memcheck/tests/arm64-linux/filter_stderr
 create mode 100644 memcheck/tests/arm64-linux/scalar.c
 create mode 100644 memcheck/tests/arm64-linux/scalar.h
 create mode 100644 memcheck/tests/arm64-linux/scalar.stderr.exp
 create mode 100644 memcheck/tests/arm64-linux/scalar.vgtest

diff --git a/configure.ac b/configure.ac
index ea08341..888a308 100644
--- a/configure.ac
+++ b/configure.ac
@@ -4134,6 +4134,7 @@ AC_CONFIG_FILES([
    memcheck/tests/darwin/Makefile
    memcheck/tests/solaris/Makefile
    memcheck/tests/amd64-linux/Makefile
+   memcheck/tests/arm64-linux/Makefile
    memcheck/tests/x86-linux/Makefile
    memcheck/tests/amd64-solaris/Makefile
    memcheck/tests/x86-solaris/Makefile
diff --git a/coregrind/m_syswrap/syswrap-arm64-linux.c b/coregrind/m_syswrap/syswrap-arm64-linux.c
index abddff1..8f4efa6 100644
--- a/coregrind/m_syswrap/syswrap-arm64-linux.c
+++ b/coregrind/m_syswrap/syswrap-arm64-linux.c
@@ -855,6 +855,11 @@ PRE(sys_rt_sigreturn)
 // (unknown).
 
 static SyscallTableEntry syscall_main_table[] = {
+   LINXY(__NR_io_setup,          sys_io_setup),          // 0
+   LINX_(__NR_io_destroy,        sys_io_destroy),        // 1
+   LINX_(__NR_io_submit,         sys_io_submit),         // 2
+   LINXY(__NR_io_cancel,         sys_io_cancel),         // 3
+   LINXY(__NR_io_getevents,      sys_io_getevents),      // 4
    LINX_(__NR_setxattr,          sys_setxattr),          // 5
    LINX_(__NR_lsetxattr,         sys_lsetxattr),         // 6
    LINX_(__NR_fsetxattr,         sys_fsetxattr),         // 7
@@ -868,20 +873,19 @@ static SyscallTableEntry syscall_main_table[] = {
    LINX_(__NR_lremovexattr,      sys_lremovexattr),      // 15
    LINX_(__NR_fremovexattr,      sys_fremovexattr),      // 16
    GENXY(__NR_getcwd,            sys_getcwd),            // 17
+   LINXY(__NR_lookup_dcookie,    sys_lookup_dcookie),    // 18
    LINXY(__NR_eventfd2,          sys_eventfd2),          // 19
    LINXY(__NR_epoll_create1,     sys_epoll_create1),     // 20
    LINX_(__NR_epoll_ctl,         sys_epoll_ctl),         // 21
    LINXY(__NR_epoll_pwait,       sys_epoll_pwait),       // 22
    GENXY(__NR_dup,               sys_dup),               // 23
    LINXY(__NR_dup3,              sys_dup3),              // 24
-
-   // FIXME IS THIS CORRECT?
-   LINXY(__NR3264_fcntl,         sys_fcntl),             // 25
-
+   LINXY(__NR_fcntl,             sys_fcntl),             // 25
    LINXY(__NR_inotify_init1,     sys_inotify_init1),     // 26
    LINX_(__NR_inotify_add_watch, sys_inotify_add_watch), // 27
    LINX_(__NR_inotify_rm_watch,  sys_inotify_rm_watch),  // 28
    LINXY(__NR_ioctl,             sys_ioctl),             // 29
+
    GENX_(__NR_flock,             sys_flock),             // 32
    LINX_(__NR_mknodat,           sys_mknodat),           // 33
    LINX_(__NR_mkdirat,           sys_mkdirat),           // 34
@@ -889,17 +893,13 @@ static SyscallTableEntry syscall_main_table[] = {
    LINX_(__NR_symlinkat,         sys_symlinkat),         // 36
    LINX_(__NR_linkat,            sys_linkat),            // 37
    LINX_(__NR_renameat,		 sys_renameat),          // 38
+   LINX_(__NR_umount2,           sys_umount),            // 39
+   LINX_(__NR_mount,             sys_mount),             // 40
 
-   LINX_(__NR_umount2,            sys_umount),           // 39
-   LINX_(__NR_mount,              sys_mount),            // 40
-
-   // FIXME IS THIS CORRECT?  it may well not be.
-   GENXY(__NR3264_statfs,        sys_statfs),            // 43
-   GENXY(__NR3264_fstatfs,       sys_fstatfs),           // 44
-
-   // FIXME IS THIS CORRECT?  it may well not be.
-   GENX_(__NR3264_ftruncate,     sys_ftruncate),         // 46
-
+   GENXY(__NR_statfs,            sys_statfs),            // 43
+   GENXY(__NR_fstatfs,           sys_fstatfs),           // 44
+   GENX_(__NR_truncate,          sys_truncate),          // 45
+   GENX_(__NR_ftruncate,         sys_ftruncate),         // 46
    LINX_(__NR_fallocate,         sys_fallocate),         // 47
    LINX_(__NR_faccessat,         sys_faccessat),         // 48
    GENX_(__NR_chdir,             sys_chdir),             // 49
@@ -911,49 +911,75 @@ static SyscallTableEntry syscall_main_table[] = {
    GENX_(__NR_fchown,            sys_fchown),            // 55
    LINXY(__NR_openat,            sys_openat),            // 56
    GENXY(__NR_close,             sys_close),             // 57
+   LINX_(__NR_vhangup,           sys_vhangup),           // 58
    LINXY(__NR_pipe2,             sys_pipe2),             // 59
    LINX_(__NR_quotactl,          sys_quotactl),          // 60
    GENXY(__NR_getdents64,        sys_getdents64),        // 61
-
-   // FIXME IS THIS CORRECT?
-   LINX_(__NR3264_lseek,         sys_lseek),             // 62
-
+   LINX_(__NR_lseek,             sys_lseek),             // 62
    GENXY(__NR_read,              sys_read),              // 63
    GENX_(__NR_write,             sys_write),             // 64
    GENXY(__NR_readv,             sys_readv),             // 65
    GENX_(__NR_writev,            sys_writev),            // 66
    GENXY(__NR_pread64,           sys_pread64),           // 67
    GENX_(__NR_pwrite64,          sys_pwrite64),          // 68
+
+   LINXY(__NR_sendfile,          sys_sendfile),          // 71
    LINXY(__NR_pselect6,          sys_pselect6),          // 72
    LINXY(__NR_ppoll,             sys_ppoll),             // 73
    LINXY(__NR_signalfd4,         sys_signalfd4),         // 74
-   LINX_(__NR_readlinkat,        sys_readlinkat),        // 78
 
-   // FIXME IS THIS CORRECT?
-   LINXY(__NR3264_fstatat,       sys_newfstatat),        // 79
-   GENXY(__NR3264_fstat,         sys_newfstat),          // 80
-
-   LINX_(__NR_utimensat,         sys_utimensat),         // 88
+   LINX_(__NR_readlinkat,        sys_readlinkat),        // 78
+   LINXY(__NR_newfstatat,        sys_newfstatat),        // 79
+   GENXY(__NR_fstat,             sys_newfstat),          // 80
+   GENX_(__NR_sync,              sys_sync),              // 81
    GENX_(__NR_fsync,             sys_fsync),             // 82
    GENX_(__NR_fdatasync,         sys_fdatasync),         // 83
+
    LINXY(__NR_timerfd_create,    sys_timerfd_create),    // 85
    LINXY(__NR_timerfd_settime,   sys_timerfd_settime),   // 86
    LINXY(__NR_timerfd_gettime,   sys_timerfd_gettime),   // 87
+   LINX_(__NR_utimensat,         sys_utimensat),         // 88
+   GENX_(__NR_acct,              sys_acct),              // 89
    LINXY(__NR_capget,            sys_capget),            // 90
+   LINX_(__NR_capset,            sys_capset),            // 91
+   LINX_(__NR_personality,       sys_personality),       // 92
    GENX_(__NR_exit,              sys_exit),              // 93
    LINX_(__NR_exit_group,        sys_exit_group),        // 94
+
    LINX_(__NR_set_tid_address,   sys_set_tid_address),   // 96
+
    LINXY(__NR_futex,             sys_futex),             // 98
    LINX_(__NR_set_robust_list,   sys_set_robust_list),   // 99
+
    GENXY(__NR_nanosleep,         sys_nanosleep),         // 101
+   GENXY(__NR_getitimer,         sys_getitimer),         // 102
    GENXY(__NR_setitimer,         sys_setitimer),         // 103
+   GENX_(__NR_kexec_load,        sys_ni_syscall),        // 104
+   LINX_(__NR_init_module,       sys_init_module),       // 105
+
+   LINXY(__NR_timer_create,      sys_timer_create),      // 107
+   LINXY(__NR_timer_settime,     sys_timer_settime),     // 108
+   LINXY(__NR_timer_gettime,     sys_timer_gettime),     // 109
+   LINX_(__NR_timer_getoverrun,  sys_timer_getoverrun),  // 110
+   LINX_(__NR_timer_delete,      sys_timer_delete),      // 111
+   LINX_(__NR_clock_settime,     sys_clock_settime),     // 112
    LINXY(__NR_clock_gettime,     sys_clock_gettime),     // 113
    LINXY(__NR_clock_getres,      sys_clock_getres),      // 114
+
    LINXY(__NR_syslog,            sys_syslog),            // 116
+
+   LINXY(__NR_sched_setparam,    sys_sched_setparam),    // 118
+   LINX_(__NR_sched_setscheduler,sys_sched_setscheduler),// 119
+   LINX_(__NR_sched_getscheduler,sys_sched_getscheduler),// 120
+   LINXY(__NR_sched_getparam,    sys_sched_getparam),    // 121
    LINX_(__NR_sched_setaffinity, sys_sched_setaffinity), // 122
    LINXY(__NR_sched_getaffinity, sys_sched_getaffinity), // 123
    LINX_(__NR_sched_yield,       sys_sched_yield),       // 124
+   LINX_(__NR_sched_get_priority_max, sys_sched_get_priority_max),// 125
+   LINX_(__NR_sched_get_priority_min, sys_sched_get_priority_min),// 126
+
    GENX_(__NR_kill,              sys_kill),              // 129
+
    LINX_(__NR_tgkill,            sys_tgkill),            // 131
    GENXY(__NR_sigaltstack,       sys_sigaltstack),       // 132
    LINX_(__NR_rt_sigsuspend,     sys_rt_sigsuspend),     // 133
@@ -965,6 +991,7 @@ static SyscallTableEntry syscall_main_table[] = {
    PLAX_(__NR_rt_sigreturn,      sys_rt_sigreturn),      // 139
    GENX_(__NR_setpriority,       sys_setpriority),       // 140
    GENX_(__NR_getpriority,       sys_getpriority),       // 141
+
    GENX_(__NR_setregid,          sys_setregid),          // 143
    GENX_(__NR_setgid,            sys_setgid),            // 144
    GENX_(__NR_setreuid,          sys_setreuid),          // 145
@@ -973,6 +1000,8 @@ static SyscallTableEntry syscall_main_table[] = {
    LINXY(__NR_getresuid,         sys_getresuid),         // 148
    LINX_(__NR_setresgid,         sys_setresgid),         // 149
    LINXY(__NR_getresgid,         sys_getresgid),         // 150
+   LINX_(__NR_setfsuid,          sys_setfsuid),          // 151
+   LINX_(__NR_setfsgid,          sys_setfsgid),          // 152
    GENXY(__NR_times,             sys_times),             // 153
    GENX_(__NR_setpgid,           sys_setpgid),           // 154
    GENX_(__NR_getpgid,           sys_getpgid),           // 155
@@ -981,12 +1010,16 @@ static SyscallTableEntry syscall_main_table[] = {
    GENXY(__NR_getgroups,         sys_getgroups),         // 158
    GENX_(__NR_setgroups,         sys_setgroups),         // 159
    GENXY(__NR_uname,             sys_newuname),          // 160
+
    GENXY(__NR_getrlimit,         sys_old_getrlimit),     // 163
    GENX_(__NR_setrlimit,         sys_setrlimit),         // 164
    GENXY(__NR_getrusage,         sys_getrusage),         // 165
    GENX_(__NR_umask,             sys_umask),             // 166
    LINXY(__NR_prctl,             sys_prctl),             // 167 
+
    GENXY(__NR_gettimeofday,      sys_gettimeofday),      // 169
+   GENX_(__NR_settimeofday,      sys_settimeofday),      // 170
+
    GENX_(__NR_getpid,            sys_getpid),            // 172
    GENX_(__NR_getppid,           sys_getppid),           // 173
    GENX_(__NR_getuid,            sys_getuid),            // 174
@@ -1033,18 +1066,20 @@ static SyscallTableEntry syscall_main_table[] = {
    GENXY(__NR_munmap,            sys_munmap),            // 215
    GENX_(__NR_mremap,            sys_mremap),            // 216
    LINX_(__NR_add_key,           sys_add_key),           // 217
+
    LINXY(__NR_keyctl,            sys_keyctl),            // 219
    PLAX_(__NR_clone,             sys_clone),             // 220
    GENX_(__NR_execve,            sys_execve),            // 221
-
-   // FIXME IS THIS CORRECT?
-   PLAX_(__NR3264_mmap,          sys_mmap),              // 222
-   PLAX_(__NR3264_fadvise64,     sys_fadvise64),         // 223
+   PLAX_(__NR_mmap,              sys_mmap),              // 222
+   PLAX_(__NR_fadvise64,         sys_fadvise64),         // 223
 
    GENXY(__NR_mprotect,          sys_mprotect),          // 226
    GENX_(__NR_msync,             sys_msync),             // 227
    GENX_(__NR_mlock,             sys_mlock),             // 228
+   GENX_(__NR_munlock,           sys_munlock),           // 229
    GENX_(__NR_mlockall,          sys_mlockall),          // 230
+   LINX_(__NR_munlockall,        sys_munlockall),        // 231
+   GENXY(__NR_mincore,           sys_mincore),           // 232
    GENX_(__NR_madvise,           sys_madvise),           // 233
    LINX_(__NR_mbind,             sys_mbind),             // 235
    LINXY(__NR_get_mempolicy,     sys_get_mempolicy),     // 236
@@ -1103,7 +1138,6 @@ static SyscallTableEntry syscall_main_table[] = {
 //ZZ    GENX_(__NR_nice,              sys_nice),           // 34
 //ZZ 
 //ZZ //   GENX_(__NR_ftime,             sys_ni_syscall),     // 35
-//ZZ    GENX_(__NR_sync,              sys_sync),           // 36
 //ZZ    GENX_(__NR_rename,            sys_rename),         // 38
 //ZZ    GENX_(__NR_mkdir,             sys_mkdir),          // 39
 //ZZ 
@@ -1116,7 +1150,6 @@ static SyscallTableEntry syscall_main_table[] = {
 //ZZ    LINX_(__NR_geteuid,           sys_geteuid16),      // 49
 //ZZ 
 //ZZ    LINX_(__NR_getegid,           sys_getegid16),      // 50
-//ZZ    GENX_(__NR_acct,              sys_acct),           // 51
 //ZZ //   GENX_(__NR_lock,              sys_ni_syscall),     // 53
 //ZZ 
 //ZZ    LINXY(__NR_fcntl,             sys_fcntl),          // 55
@@ -1138,7 +1171,6 @@ static SyscallTableEntry syscall_main_table[] = {
 //ZZ //zz    //   (__NR_sethostname,       sys_sethostname),    // 74 */*
 //ZZ //zz 
 //ZZ    GENXY(__NR_getrlimit,         sys_old_getrlimit),  // 76
-//ZZ    GENX_(__NR_settimeofday,      sys_settimeofday),   // 79
 //ZZ 
 //ZZ    LINXY(__NR_getgroups,         sys_getgroups16),    // 80
 //ZZ    LINX_(__NR_setgroups,         sys_setgroups16),    // 81
@@ -1165,14 +1197,12 @@ static SyscallTableEntry syscall_main_table[] = {
 //ZZ //   LINX_(__NR_ioperm,            sys_ioperm),         // 101
 //ZZ    LINXY(__NR_socketcall,        sys_socketcall),     // 102
 //ZZ 
-//ZZ    GENXY(__NR_getitimer,         sys_getitimer),      // 105
 //ZZ    GENXY(__NR_stat,              sys_newstat),        // 106
 //ZZ    GENXY(__NR_lstat,             sys_newlstat),       // 107
 //ZZ    GENXY(__NR_fstat,             sys_newfstat),       // 108
 //ZZ //zz    //   (__NR_olduname,          sys_uname),          // 109 -- obsolete
 //ZZ //zz 
 //ZZ //   GENX_(__NR_iopl,              sys_iopl),           // 110
-//ZZ    LINX_(__NR_vhangup,           sys_vhangup),        // 111
 //ZZ //   GENX_(__NR_idle,              sys_ni_syscall),     // 112
 //ZZ // PLAXY(__NR_vm86old,           sys_vm86old),        // 113 __NR_syscall... weird
 //ZZ //zz 
@@ -1188,7 +1218,6 @@ static SyscallTableEntry syscall_main_table[] = {
 //ZZ    LINXY(__NR_sigprocmask,       sys_sigprocmask),    // 126
 //ZZ //zz    // Nb: create_module() was removed 2.4-->2.6
 //ZZ //   GENX_(__NR_create_module,     sys_ni_syscall),     // 127
-//ZZ    LINX_(__NR_init_module,       sys_init_module),    // 128
 //ZZ    LINX_(__NR_delete_module,     sys_delete_module),  // 129
 //ZZ //zz 
 //ZZ //zz    // Nb: get_kernel_syms() was removed 2.4-->2.6
@@ -1197,10 +1226,7 @@ static SyscallTableEntry syscall_main_table[] = {
 //ZZ //zz    //   (__NR_bdflush,           sys_bdflush),        // 134 */Linux
 //ZZ //zz 
 //ZZ //zz    //   (__NR_sysfs,             sys_sysfs),          // 135 SVr4
-//ZZ    LINX_(__NR_personality,       sys_personality),    // 136
 //ZZ //   GENX_(__NR_afs_syscall,       sys_ni_syscall),     // 137
-//ZZ    LINX_(__NR_setfsuid,          sys_setfsuid16),     // 138
-//ZZ    LINX_(__NR_setfsgid,          sys_setfsgid16),     // 139
 //ZZ  
 //ZZ    LINXY(__NR__llseek,           sys_llseek),         // 140
 //ZZ    GENXY(__NR_getdents,          sys_getdents),       // 141
@@ -1208,16 +1234,6 @@ static SyscallTableEntry syscall_main_table[] = {
 //ZZ 
 //ZZ    LINXY(__NR__sysctl,           sys_sysctl),         // 149
 //ZZ 
-//ZZ    GENX_(__NR_munlock,           sys_munlock),        // 151
-//ZZ    LINX_(__NR_munlockall,        sys_munlockall),     // 153
-//ZZ    LINXY(__NR_sched_setparam,    sys_sched_setparam), // 154
-//ZZ 
-//ZZ    LINXY(__NR_sched_getparam,         sys_sched_getparam),        // 155
-//ZZ    LINX_(__NR_sched_setscheduler,     sys_sched_setscheduler),    // 156
-//ZZ    LINX_(__NR_sched_getscheduler,     sys_sched_getscheduler),    // 157
-//ZZ    LINX_(__NR_sched_get_priority_max, sys_sched_get_priority_max),// 159
-//ZZ 
-//ZZ    LINX_(__NR_sched_get_priority_min, sys_sched_get_priority_min),// 160
 //ZZ //zz    //LINX?(__NR_sched_rr_get_interval,  sys_sched_rr_get_interval), // 161 */*
 //ZZ    LINX_(__NR_setresuid,         sys_setresuid16),    // 164
 //ZZ 
@@ -1236,7 +1252,6 @@ static SyscallTableEntry syscall_main_table[] = {
 //ZZ 
 //ZZ    LINX_(__NR_chown,             sys_chown16),        // 182
 //ZZ 
-//ZZ    LINX_(__NR_capset,            sys_capset),         // 185
 //ZZ    LINXY(__NR_sendfile,          sys_sendfile),       // 187
 //ZZ //   GENXY(__NR_getpmsg,           sys_getpmsg),        // 188
 //ZZ //   GENX_(__NR_putpmsg,           sys_putpmsg),        // 189
@@ -1271,42 +1286,26 @@ static SyscallTableEntry syscall_main_table[] = {
 //ZZ    LINX_(__NR_setfsuid32,        sys_setfsuid),       // 215
 //ZZ    LINX_(__NR_setfsgid32,        sys_setfsgid),       // 216
 //ZZ //zz    //   (__NR_pivot_root,        sys_pivot_root),     // 217 */Linux
-//ZZ    GENXY(__NR_mincore,           sys_mincore),        // 218
 //ZZ 
 //ZZ    LINXY(__NR_fcntl64,           sys_fcntl64),        // 221
 //ZZ //   GENX_(222,                    sys_ni_syscall),     // 222
 //ZZ //   PLAXY(223,                    sys_syscall223),     // 223 // sys_bproc?
 //ZZ 
 //ZZ    LINXY(__NR_tkill,             sys_tkill),          // 238 */Linux
-//ZZ    LINXY(__NR_sendfile64,        sys_sendfile64),     // 239
 //ZZ 
 //ZZ    LINXY(__NR_futex,             sys_futex),             // 240
 //ZZ    LINXY(__NR_sched_getaffinity, sys_sched_getaffinity), // 242
 //ZZ //   PLAX_(__NR_set_thread_area,   sys_set_thread_area),   // 243
 //ZZ //   PLAX_(__NR_get_thread_area,   sys_get_thread_area),   // 244
 //ZZ 
-//ZZ    LINXY(__NR_io_setup,          sys_io_setup),       // 245
-//ZZ    LINX_(__NR_io_destroy,        sys_io_destroy),     // 246
-//ZZ    LINXY(__NR_io_getevents,      sys_io_getevents),   // 247
-//ZZ    LINX_(__NR_io_submit,         sys_io_submit),      // 248
-//ZZ    LINXY(__NR_io_cancel,         sys_io_cancel),      // 249
-//ZZ 
 //ZZ //   LINX_(__NR_fadvise64,         sys_fadvise64),      // 250 */(Linux?)
 //ZZ    GENX_(251,                    sys_ni_syscall),     // 251
-//ZZ //   GENXY(__NR_lookup_dcookie,    sys_lookup_dcookie), // 253
 //ZZ    LINXY(__NR_epoll_create,      sys_epoll_create),   // 254
 //ZZ 
 //ZZ    LINX_(__NR_epoll_ctl,         sys_epoll_ctl),         // 255
 //ZZ    LINXY(__NR_epoll_wait,        sys_epoll_wait),        // 256
 //ZZ //zz    //   (__NR_remap_file_pages,  sys_remap_file_pages),  // 257 */Linux
 //ZZ    LINX_(__NR_set_tid_address,   sys_set_tid_address),   // 258
-//ZZ    LINXY(__NR_timer_create,      sys_timer_create),      // 259
-//ZZ 
-//ZZ    LINXY(__NR_timer_settime,     sys_timer_settime),  // (timer_create+1)
-//ZZ    LINXY(__NR_timer_gettime,     sys_timer_gettime),  // (timer_create+2)
-//ZZ    LINX_(__NR_timer_getoverrun,  sys_timer_getoverrun),//(timer_create+3)
-//ZZ    LINX_(__NR_timer_delete,      sys_timer_delete),   // (timer_create+4)
-//ZZ    LINX_(__NR_clock_settime,     sys_clock_settime),  // (timer_create+5)
 //ZZ 
 //ZZ    LINXY(__NR_clock_getres,      sys_clock_getres),   // (timer_create+7)
 //ZZ    LINXY(__NR_clock_nanosleep,   sys_clock_nanosleep),// (timer_create+8) */*
diff --git a/coregrind/m_syswrap/syswrap-linux.c b/coregrind/m_syswrap/syswrap-linux.c
index 6fdacda..fa7f89e 100644
--- a/coregrind/m_syswrap/syswrap-linux.c
+++ b/coregrind/m_syswrap/syswrap-linux.c
@@ -5325,7 +5325,7 @@ POST(sys_lookup_dcookie)
 #endif
 
 #if defined(VGP_amd64_linux) || defined(VGP_s390x_linux)        \
-      || defined(VGP_tilegx_linux)
+      || defined(VGP_tilegx_linux) || defined(VGP_arm64_linux)
 PRE(sys_lookup_dcookie)
 {
    *flags |= SfMayBlock;
diff --git a/memcheck/tests/Makefile.am b/memcheck/tests/Makefile.am
index 368239f..8557a19 100644
--- a/memcheck/tests/Makefile.am
+++ b/memcheck/tests/Makefile.am
@@ -38,6 +38,9 @@ endif
 if VGCONF_PLATFORMS_INCLUDE_AMD64_LINUX
 SUBDIRS += amd64-linux
 endif
+if VGCONF_PLATFORMS_INCLUDE_ARM64_LINUX
+SUBDIRS += arm64-linux
+endif
 if VGCONF_PLATFORMS_INCLUDE_X86_SOLARIS
 SUBDIRS += x86-solaris
 endif
@@ -46,7 +49,8 @@ SUBDIRS += amd64-solaris
 endif
 
 DIST_SUBDIRS = x86 amd64 ppc32 ppc64 s390x linux \
-		darwin solaris x86-linux amd64-linux x86-solaris amd64-solaris \
+		darwin solaris x86-linux amd64-linux arm64-linux \
+		x86-solaris amd64-solaris \
 		common .
 
 dist_noinst_SCRIPTS = \
diff --git a/memcheck/tests/arm64-linux/Makefile.am b/memcheck/tests/arm64-linux/Makefile.am
new file mode 100644
index 0000000..284d83f
--- /dev/null
+++ b/memcheck/tests/arm64-linux/Makefile.am
@@ -0,0 +1,19 @@
+
+include $(top_srcdir)/Makefile.tool-tests.am
+
+dist_noinst_SCRIPTS = \
+	filter_stderr
+
+noinst_HEADERS = scalar.h
+
+EXTRA_DIST = \
+	scalar.stderr.exp scalar.vgtest
+
+check_PROGRAMS = \
+	scalar
+
+
+AM_CFLAGS    += @FLAG_M64@
+AM_CXXFLAGS  += @FLAG_M64@
+AM_CCASFLAGS += @FLAG_M64@
+
diff --git a/memcheck/tests/arm64-linux/filter_stderr b/memcheck/tests/arm64-linux/filter_stderr
new file mode 100755
index 0000000..a778e97
--- /dev/null
+++ b/memcheck/tests/arm64-linux/filter_stderr
@@ -0,0 +1,3 @@
+#! /bin/sh
+
+../filter_stderr "$@"
diff --git a/memcheck/tests/arm64-linux/scalar.c b/memcheck/tests/arm64-linux/scalar.c
new file mode 100644
index 0000000..e8f2e43
--- /dev/null
+++ b/memcheck/tests/arm64-linux/scalar.c
@@ -0,0 +1,1278 @@
+/* This is the arm64 variant of memcheck/tests/x86-linux/scalar.c
+   syscalls are in x86 number order to make exp comparison easier. */
+#define _GNU_SOURCE
+#include "../../memcheck.h"
+#include "scalar.h"
+#include <unistd.h>
+#include <sched.h>
+#include <signal.h>
+#include <linux/mman.h> // MREMAP_FIXED
+
+// Here we are trying to trigger every syscall error (scalar errors and
+// memory errors) for every syscall.  We do this by passing a lot of bogus
+// arguments, mostly 0 and 1 (often it's 1 because NULL ptr args often aren't
+// checked for memory errors, or in order to have a non-zero length used
+// with some buffer).  So most of the syscalls don't actually succeed and do
+// anything.
+//
+// Occasionally we have to be careful not to cause Valgrind to seg fault in
+// its pre-syscall wrappers;  it does so because it can't know in general
+// when memory is unaddressable, and so tries to dereference it when doing
+// PRE_MEM_READ/PRE_MEM_WRITE calls.  (Note that Memcheck will
+// always issue an error message immediately before these seg faults occur).
+//
+// The output has numbers like "3s 2m" for each syscall.  "s" is short for
+// "scalar", ie. the argument itself is undefined.  "m" is short for "memory",
+// ie. the argument points to memory which is unaddressable.
+int main(void)
+{
+   // uninitialised, but we know px[0] is 0x0
+   long* px  = malloc(sizeof(long));
+   long  x0  = px[0];
+   long  res;
+
+   // All __NR_xxx numbers are taken from x86
+
+   // __NR_restart_syscall 0  // XXX: not yet handled, perhaps should be...
+   GO(__NR_restart_syscall, "n/a");
+ //SY(__NR_restart_syscall); // (Not yet handled by Valgrind) FAIL;
+
+   // __NR_exit 1 
+   GO(__NR_exit, "below");
+   // (see below)
+
+   // __NR_fork arm64 only has clone
+   //GO(__NR_fork, "other");
+   // (sse scalar_fork.c)
+
+   // __NR_read 3
+   // Nb: here we are also getting an error from the syscall arg itself.
+   GO(__NR_read, "1+3s 1m");
+   SY(__NR_read+x0, x0, x0, x0+1); FAILx(EFAULT);
+
+   // __NR_write 4
+   GO(__NR_write, "3s 1m");
+   SY(__NR_write, x0, x0, x0+1); FAIL;
+
+   // __NR_open arm64 only as openat.
+   //GO(__NR_open, "(2-args) 2s 1m");
+   //SY(__NR_open, x0, x0); FAIL;
+
+   // Only 1s 0m errors -- the other 2s 1m have been checked in the previous
+   // open test, and if we test them they may be commoned up but they also
+   // may not. arm64 only has openat.
+   //GO(__NR_open, "(3-args) 1s 0m");    
+   //SY(__NR_open, "scalar.c", O_CREAT|O_EXCL, x0); FAIL;
+
+   // __NR_close 6
+   GO(__NR_close, "1s 0m");
+   SY(__NR_close, x0-1); FAIL;
+
+   // __NR_waitpid arm64 only has waitid.
+   //GO(__NR_waitpid, "3s 1m");
+   //SY(__NR_waitpid, x0, x0+1, x0); FAIL;
+
+   // __NR_creat arm64 only has openat
+   //GO(__NR_creat, "2s 1m");
+   //SY(__NR_creat, x0, x0); FAIL;
+
+   // __NR_link arm64 only has linkat
+   //GO(__NR_link, "2s 2m");
+   //SY(__NR_link, x0, x0); FAIL;
+
+   // __NR_unlink arm64 only has unlinkat
+   //GO(__NR_unlink, "1s 1m");
+   //SY(__NR_unlink, x0); FAIL;
+
+   // __NR_execve 11
+   // Nb: could have 3 memory errors if we pass x0+1 as the 2nd and 3rd
+   // args, except for bug #93174.
+   GO(__NR_execve, "3s 1m");
+   SY(__NR_execve, x0, x0, x0); FAIL;
+
+   // __NR_chdir 12
+   GO(__NR_chdir, "1s 1m");
+   SY(__NR_chdir, x0); FAIL;
+
+   // __NR_time on arm64 time is provided in the vdso
+   //GO(__NR_time, "1s 1m");
+   //SY(__NR_time, x0+1); FAIL;
+
+   // __NR_mknod arm64 only has mknodat
+   //GO(__NR_mknod, "3s 1m");
+   //SY(__NR_mknod, x0, x0, x0); FAIL;
+
+   // __NR_chmod arm64 only has chmodat
+   //GO(__NR_chmod, "2s 1m");
+   //SY(__NR_chmod, x0, x0); FAIL;
+
+   // __NR_lchown arm64 only has lchownat
+   //GO(__NR_lchown, "n/a");
+ //SY(__NR_lchown); // (Not yet handled by Valgrind) FAIL;
+
+   // __NR_break arm64 has no break
+   //GO(__NR_break, "ni");
+   //SY(__NR_break); FAIL;
+
+   // __NR_oldstat arm64 has no oldstat
+   //GO(__NR_oldstat, "n/a");
+   // (obsolete, not handled by Valgrind)
+
+   // __NR_lseek 19
+   GO(__NR_lseek, "3s 0m");
+   SY(__NR_lseek, x0-1, x0, x0); FAILx(EBADF);
+
+   // __NR_getpid 20
+   GO(__NR_getpid, "0s 0m");
+   SY(__NR_getpid); SUCC;
+
+   // __NR_mount 21
+   GO(__NR_mount, "5s 3m");
+   SY(__NR_mount, x0, x0, x0, x0, x0); FAIL;
+   
+   // __NR_umount arm64 only has umount2
+   //GO(__NR_umount, "1s 1m");
+   //SY(__NR_umount, x0); FAIL;
+
+   // __NR_setuid 23
+   GO(__NR_setuid, "1s 0m");
+   SY(__NR_setuid, x0); FAIL;
+
+   // __NR_getuid 24
+   GO(__NR_getuid, "0s 0m");
+   SY(__NR_getuid); SUCC;
+
+   // __NR_stime arm64 does not have stime
+   //GO(__NR_stime, "n/a");
+ //SY(__NR_stime); // (Not yet handled by Valgrind) FAIL;
+
+   // __NR_ptrace arm64 does not use PTRACE_GETREGS
+   // XXX: memory pointed to be arg3 goes unchecked... otherwise would be 2m
+   //GO(__NR_ptrace, "4s 1m");
+   //SY(__NR_ptrace, x0+PTRACE_GETREGS, x0, x0, x0); FAIL;
+
+   // __NR_alarm arm64 only has ualarm
+   //GO(__NR_alarm, "1s 0m");
+   //SY(__NR_alarm, x0); SUCC;
+
+   // __NR_oldfstat arm64 does not have oldfstat
+   //GO(__NR_oldfstat, "n/a");
+   // (obsolete, not handled by Valgrind)
+
+   // __NR_pause arm64 does not have pause
+   //GO(__NR_pause, "ignore");
+   // (hard to test, and no args so not much to be gained -- don't bother)
+
+   // __NR_utime arm64 only has utimes
+   //GO(__NR_utime, "2s 2m");
+   //SY(__NR_utime, x0, x0+1); FAIL;
+
+   // __NR_stty arm64 doesn't have stty.
+   //GO(__NR_stty, "ni");
+   //SY(__NR_stty); FAIL;
+
+   // __NR_gtty arm64 doesm't have gtty.
+   //GO(__NR_gtty, "ni");
+   //SY(__NR_gtty); FAIL;
+
+   // __NR_access arm64 only has fsaccessat
+   //GO(__NR_access, "2s 1m");
+   //SY(__NR_access, x0, x0); FAIL;
+
+   // __NR_nice arm64 only has setpriority
+   //GO(__NR_nice, "1s 0m");
+   //SY(__NR_nice, x0); SUCC;
+
+   // __NR_ftime arm64 doesn't implement ftime
+   //GO(__NR_ftime, "ni");
+   //SY(__NR_ftime); FAIL;
+
+   // __NR_sync 36
+   GO(__NR_sync, "0s 0m");
+   SY(__NR_sync); SUCC;
+
+   // __NR_kill 37
+   GO(__NR_kill, "2s 0m");
+   SY(__NR_kill, x0, x0); SUCC;
+
+   // __NR_rename arm64 only has renameat
+   //GO(__NR_rename, "2s 2m");
+   //SY(__NR_rename, x0, x0); FAIL;
+
+   // __NR_mkdir arm64 only has mkdirat
+   //GO(__NR_mkdir, "2s 1m");
+   //SY(__NR_mkdir, x0, x0); FAIL;
+
+   // __NR_rmdir arm64 only has rmdirat
+   //GO(__NR_rmdir, "1s 1m");
+   //SY(__NR_rmdir, x0); FAIL;
+
+   // __NR_dup 41
+   GO(__NR_dup, "1s 0m");
+   SY(__NR_dup, x0-1); FAIL;
+
+   // __NR_pipe arm64 only has pipe2
+   //GO(__NR_pipe, "1s 1m");
+   //SY(__NR_pipe, x0); FAIL;
+
+   // __NR_times 43
+   GO(__NR_times, "1s 1m");
+   SY(__NR_times, x0+1); FAIL;
+
+   // __NR_prof arm64 doesn't implement prof
+   //GO(__NR_prof, "ni");
+   //SY(__NR_prof); FAIL;
+
+   // __NR_brk 45
+   GO(__NR_brk, "1s 0m");
+   SY(__NR_brk, x0); SUCC;
+
+   // __NR_setgid 46
+   GO(__NR_setgid, "1s 0m");
+   SY(__NR_setgid, x0); FAIL;
+
+   // __NR_getgid 47
+   GO(__NR_getgid, "0s 0m");
+   SY(__NR_getgid); SUCC;
+
+   // __NR_signal arm64 only has rt_sigaction
+   //GO(__NR_signal, "n/a");
+ //SY(__NR_signal); // (Not yet handled by Valgrind) FAIL;
+
+   // __NR_geteuid 49
+   GO(__NR_geteuid, "0s 0m");
+   SY(__NR_geteuid); SUCC;
+
+   // __NR_getegid 50
+   GO(__NR_getegid, "0s 0m");
+   SY(__NR_getegid); SUCC;
+
+   // __NR_acct 51
+   GO(__NR_acct, "1s 1m");
+   SY(__NR_acct, x0); FAIL;
+
+   // __NR_umount2 52
+   GO(__NR_umount2, "2s 1m");
+   SY(__NR_umount2, x0, x0); FAIL;
+
+   // __NR_lock arm64 doesn't implement lock
+   //GO(__NR_lock, "ni");
+   //SY(__NR_lock); FAIL;
+
+   // __NR_ioctl 54
+   #include <asm/ioctls.h>
+   GO(__NR_ioctl, "3s 1m");
+   SY(__NR_ioctl, x0, x0+TCSETS, x0); FAIL;
+
+   // __NR_fcntl 55
+   // As with sys_open(), the 'fd' error is suppressed for the later ones.
+   // For F_GETFD the 3rd arg is ignored
+   GO(__NR_fcntl, "(GETFD) 2s 0m");
+   SY(__NR_fcntl, x0-1, x0+F_GETFD, x0); FAILx(EBADF);
+
+   // For F_DUPFD the 3rd arg is 'arg'.  We don't check the 1st two args
+   // because any errors may or may not be commoned up with the ones from
+   // the previous fcntl call.
+   GO(__NR_fcntl, "(DUPFD) 1s 0m");
+   SY(__NR_fcntl, -1, F_DUPFD, x0); FAILx(EBADF);
+
+   // For F_GETLK the 3rd arg is 'lock'.  On x86, this fails w/EBADF.  But
+   // on amd64 in 32-bit mode it fails w/EFAULT.  We don't check the 1st two
+   // args for the reason given above.
+   GO(__NR_fcntl, "(GETLK) 1s 0m");
+   SY(__NR_fcntl, -1, F_GETLK, x0); FAIL; //FAILx(EBADF);
+
+   // __NR_mpx arm64 doesn't implement mpx
+   //GO(__NR_mpx, "ni");
+   //SY(__NR_mpx); FAIL;
+
+   // __NR_setpgid 57
+   GO(__NR_setpgid, "2s 0m");
+   SY(__NR_setpgid, x0, x0-1); FAIL;
+
+   // __NR_ulimit arm64 doesn't implement ulimit
+   //GO(__NR_ulimit, "ni");
+   //SY(__NR_ulimit); FAIL;
+
+   // __NR_oldolduname arm64 doesn't implement oldolduname,
+   //GO(__NR_oldolduname, "n/a");
+   // (obsolete, not handled by Valgrind)
+
+   // __NR_umask 60
+   GO(__NR_umask, "1s 0m");
+   SY(__NR_umask, x0+022); SUCC;
+
+   // __NR_chroot 61
+   GO(__NR_chroot, "1s 1m");
+   SY(__NR_chroot, x0); FAIL;
+
+   // __NR_ustat arm64 only has statfs
+   //GO(__NR_ustat, "n/a");
+   // (deprecated, not handled by Valgrind)
+
+   // __NR_dup2 arm64 only has dup or dup3
+   //GO(__NR_dup2, "2s 0m");
+   //SY(__NR_dup2, x0-1, x0); FAIL;
+
+   // __NR_getppid 64
+   GO(__NR_getppid, "0s 0m");
+   SY(__NR_getppid); SUCC;
+
+   // __NR_getpgrp arm64 only has getpgid
+   //GO(__NR_getpgrp, "0s 0m");
+   //SY(__NR_getpgrp); SUCC;
+
+   // __NR_setsid 66
+   GO(__NR_setsid, "0s 0m");
+   SY(__NR_setsid); SUCC_OR_FAIL;
+
+   // __NR_sigaction arm64 only has rt_sigaction
+   //GO(__NR_sigaction, "3s 4m");
+   //SY(__NR_sigaction, x0, x0+&px[1], x0+&px[1]); FAIL;
+
+   // __NR_sgetmask arm64 only has rt_sigprocmask
+   //GO(__NR_sgetmask, "n/a");
+ //SY(__NR_sgetmask); // (Not yet handled by Valgrind) FAIL;
+
+   // __NR_ssetmask arm64 only has rt_sigprocmask
+   //GO(__NR_ssetmask, "n/a");
+ //SY(__NR_ssetmask); // (Not yet handled by Valgrind) FAIL;
+
+   // __NR_setreuid 70
+   GO(__NR_setreuid, "2s 0m");
+   SY(__NR_setreuid, x0, x0); FAIL;
+
+   // __NR_setregid 71
+   GO(__NR_setregid, "2s 0m");
+   SY(__NR_setregid, x0, x0); FAIL;
+
+   // __NR_sigsuspend arm64 only has rt_sigsuspend
+   // XXX: how do you use this function?
+   //GO(__NR_sigsuspend, "ignore");
+   // (I don't know how to test this...)
+
+   // __NR_sigpending arm64 only has rt_sigpending
+   //GO(__NR_sigpending, "1s 1m");
+   //SY(__NR_sigpending, x0); FAIL;
+
+   // __NR_sethostname 74
+   GO(__NR_sethostname, "n/a");
+ //SY(__NR_sethostname); // (Not yet handled by Valgrind) FAIL;
+
+   // __NR_setrlimit 75
+   GO(__NR_setrlimit, "2s 1m");
+   SY(__NR_setrlimit, x0, x0); FAIL;
+
+   // __NR_getrlimit 76
+   GO(__NR_getrlimit, "2s 1m");
+   SY(__NR_getrlimit, x0, x0); FAIL;
+
+   // __NR_getrusage 77
+   GO(__NR_getrusage, "2s 1m");
+   SY(__NR_getrusage, x0, x0); FAIL;
+
+   // __NR_gettimeofday 78
+   GO(__NR_gettimeofday, "2s 2m");
+   SY(__NR_gettimeofday, x0+1, x0+1); FAIL;
+
+   // __NR_settimeofday 79
+   GO(__NR_settimeofday, "2s 2m");
+   SY(__NR_settimeofday, x0+1, x0+1); FAIL;
+
+   // __NR_getgroups 80
+   GO(__NR_getgroups, "2s 1m");
+   SY(__NR_getgroups, x0+1, x0+1); FAIL;
+
+   // __NR_setgroups 81
+   GO(__NR_setgroups, "2s 1m");
+   SY(__NR_setgroups, x0+1, x0+1); FAIL;
+
+   // __NR_select arm64 only has pselect6
+   //{
+   //   long args[5] = { x0+8, x0+0xffffffee, x0+1, x0+1, x0+1 };
+   //   GO(__NR_select, "1s 5m");
+   //   SY(__NR_select, args+x0); FAIL;
+   //}
+
+   // __NR_symlink arm64 only has symlinkat
+   //GO(__NR_symlink, "2s 2m");
+   //SY(__NR_symlink, x0, x0); FAIL;
+
+   // __NR_oldlstat arm64 doesn't implement oldlstat
+   //GO(__NR_oldlstat, "n/a");
+   // (obsolete, not handled by Valgrind)
+
+   // __NR_readlink arm64 only has readlinkat
+   //GO(__NR_readlink, "3s 2m");
+   //SY(__NR_readlink, x0+1, x0+1, x0+1); FAIL;
+
+   // __NR_uselib arm64 doesn't implement uselib
+   //GO(__NR_uselib, "n/a");
+ //SY(__NR_uselib); // (Not yet handled by Valgrind) FAIL;
+
+   // __NR_swapon 87
+   GO(__NR_swapon, "n/a");
+ //SY(__NR_swapon); // (Not yet handled by Valgrind) FAIL;
+
+   // __NR_reboot 88
+   GO(__NR_reboot, "n/a");
+ //SY(__NR_reboot); // (Not yet handled by Valgrind) FAIL;
+
+   // __NR_readdir arm64 only implements getdents64
+   //GO(__NR_readdir, "n/a");
+   // (superseded, not handled by Valgrind)
+
+   // __NR_mmap 90
+   {
+      long args[6] = { x0, x0, x0, x0, x0-1, x0 };
+      GO(__NR_mmap, "1s 1m");
+      SY(__NR_mmap, args+x0); FAIL;
+   }
+
+   // __NR_munmap 91
+   GO(__NR_munmap, "2s 0m");
+   SY(__NR_munmap, x0, x0); FAIL;
+
+   // __NR_truncate 92
+   GO(__NR_truncate, "2s 1m");
+   SY(__NR_truncate, x0, x0); FAIL;
+
+   // __NR_ftruncate 93
+   GO(__NR_ftruncate, "2s 0m");
+   SY(__NR_ftruncate, x0, x0); FAIL;
+
+   // __NR_fchmod 94
+   GO(__NR_fchmod, "2s 0m");
+   SY(__NR_fchmod, x0-1, x0); FAIL;
+
+   // __NR_fchown 95
+   GO(__NR_fchown, "3s 0m");
+   SY(__NR_fchown, x0, x0, x0); FAIL;
+
+   // __NR_getpriority 96
+   GO(__NR_getpriority, "2s 0m");
+   SY(__NR_getpriority, x0-1, x0); FAIL;
+
+   // __NR_setpriority 97
+   GO(__NR_setpriority, "3s 0m");
+   SY(__NR_setpriority, x0-1, x0, x0); FAIL;
+
+   // __NR_profil arm64 doesn't implement profil.
+   //GO(__NR_profil, "ni");
+   //SY(__NR_profil); FAIL;
+
+   // __NR_statfs 99
+   GO(__NR_statfs, "2s 2m");
+   SY(__NR_statfs, x0, x0); FAIL;
+
+   // __NR_fstatfs 100
+   GO(__NR_fstatfs, "2s 1m");
+   SY(__NR_fstatfs, x0, x0); FAIL;
+
+   // __NR_ioperm arm64 doesn't implement ioperm
+   //GO(__NR_ioperm, "3s 0m");
+   //SY(__NR_ioperm, x0, x0, x0); FAIL;
+
+   // __NR_socketcall arm64 doesn't have socketcall.
+   //GO(__NR_socketcall, "XXX");
+   // (XXX: need to do all sub-cases properly)
+
+   // __NR_syslog 103
+   GO(__NR_syslog, "3s 1m");
+   SY(__NR_syslog, x0+2, x0, x0+1); FAIL;
+
+   // __NR_setitimer 104
+   GO(__NR_setitimer, "3s 2m");
+   SY(__NR_setitimer, x0, x0+1, x0+1); FAIL;
+
+   // __NR_getitimer 105
+   GO(__NR_getitimer, "2s 1m");
+   SY(__NR_getitimer, x0, x0, x0); FAIL;
+
+   // __NR_stat arm64 doesn't implement stat
+   //GO(__NR_stat, "2s 2m");
+   //SY(__NR_stat, x0, x0); FAIL;
+
+   // __NR_lstat arm64 doesn't implement lstat
+   //GO(__NR_lstat, "2s 2m");
+   //SY(__NR_lstat, x0, x0); FAIL;
+
+   // __NR_fstat 108
+   GO(__NR_fstat, "2s 1m");
+   SY(__NR_fstat, x0, x0); FAIL;
+
+   // __NR_olduname arm64 doesn't implement olduname
+   //GO(__NR_olduname, "n/a");
+   // (obsolete, not handled by Valgrind)
+
+   // __NR_iopl arm64 doesn't implement iopl
+   //GO(__NR_iopl, "1s 0m");
+   //SY(__NR_iopl, x0+100); FAIL;
+
+   // __NR_vhangup 111
+   GO(__NR_vhangup, "0s 0m");
+   SY(__NR_vhangup); SUCC_OR_FAIL;  // Will succeed for superuser
+   
+   // __NR_idle arm64 doesn't implement idle.
+   //GO(__NR_idle, "ni");
+   //SY(__NR_idle); FAIL;
+
+   // __NR_vm86old arm64 doesn't implement vm86old
+   //GO(__NR_vm86old, "n/a");
+   // (will probably never be handled by Valgrind)
+
+   // __NR_wait4 114
+   GO(__NR_wait4, "4s 2m");
+   SY(__NR_wait4, x0, x0+1, x0, x0+1); FAIL;
+
+   // __NR_swapoff 115
+   GO(__NR_swapoff, "n/a");
+ //SY(__NR_swapoff); // (Not yet handled by Valgrind) FAIL;
+
+   // __NR_sysinfo 116
+   GO(__NR_sysinfo, "1s 1m");
+   SY(__NR_sysinfo, x0); FAIL;
+
+   // __NR_ipc arm64 has separate msgctl semctl shmctl system calls
+   // XXX: This is simplistic -- need to do all the sub-cases properly.
+   // XXX: Also, should be 6 scalar errors, except glibc's syscall() doesn't
+   //      use the 6th one!
+   //GO(__NR_ipc, "5s 0m");
+   //SY(__NR_ipc, x0+4, x0, x0, x0, x0, x0); FAIL;
+
+   // __NR_fsync 118
+   GO(__NR_fsync, "1s 0m");
+   SY(__NR_fsync, x0-1); FAIL;
+
+   // __NR_sigreturn arm64 only has rt_sigreturn
+   //GO(__NR_sigreturn, "n/a");
+ //SY(__NR_sigreturn); // (Not yet handled by Valgrind) FAIL;
+
+   // __NR_clone 120
+#ifndef CLONE_PARENT_SETTID
+#define CLONE_PARENT_SETTID	0x00100000
+#endif
+   GO(__NR_clone, "5s 3m");
+   SY(__NR_clone, x0|CLONE_PARENT_SETTID|CLONE_SETTLS|CLONE_CHILD_SETTID|SIGCHLD, x0, x0, x0, x0); FAIL;
+   if (0 == res) {
+      SY(__NR_exit, 0); FAIL;
+   }
+
+   // __NR_setdomainname 121
+   GO(__NR_setdomainname, "n/a");
+ //SY(__NR_setdomainname); // (Not yet handled by Valgrind) FAIL;
+
+   // __NR_uname 122
+   GO(__NR_uname, "1s 1m");
+   SY(__NR_uname, x0); FAIL;
+
+   // __NR_modify_ldt arm64 doesn't implement modify_ldt
+   //GO(__NR_modify_ldt, "3s 1m");
+   //SY(__NR_modify_ldt, x0+1, x0, x0+1); FAILx(EINVAL);
+
+   // __NR_adjtimex 124
+   // XXX: need to do properly, but deref'ing NULL causing Valgrind to crash...
+     GO(__NR_adjtimex, "XXX");
+//   SY(__NR_adjtimex, x0); FAIL;
+
+   // __NR_mprotect 125
+   GO(__NR_mprotect, "3s 0m");
+   SY(__NR_mprotect, x0+1, x0, x0); FAILx(EINVAL);
+
+   // __NR_sigprocmask arm64 has rt_sigprocmask
+   //GO(__NR_sigprocmask, "3s 2m");
+   //SY(__NR_sigprocmask, x0, x0+&px[1], x0+&px[1]); SUCC;
+
+   // __NR_create_module arm64 doesn't implement create_module.
+   //GO(__NR_create_module, "ni");
+   //SY(__NR_create_module); FAIL;
+
+   // __NR_init_module 128
+   GO(__NR_init_module, "3s 2m");
+   SY(__NR_init_module, x0, x0+1, x0); FAIL;
+
+   // __NR_delete_module 129
+   GO(__NR_delete_module, "n/a");
+ //SY(__NR_delete_module); // (Not yet handled by Valgrind) FAIL;
+
+   // __NR_get_kernel_syms arm64 doesn't implement get_kernel_syms
+   //GO(__NR_get_kernel_syms, "ni");
+   //SY(__NR_get_kernel_syms); FAIL;
+
+   // __NR_quotactl 131
+   GO(__NR_quotactl, "4s 1m");
+   SY(__NR_quotactl, x0, x0, x0, x0); FAIL;
+
+   // __NR_getpgid 132
+   GO(__NR_getpgid, "1s 0m");
+   SY(__NR_getpgid, x0-1); FAIL;
+
+   // __NR_fchdir 133
+   GO(__NR_fchdir, "1s 0m");
+   SY(__NR_fchdir, x0-1); FAIL;
+
+   // __NR_bdflush arm64 doesn't implement bdflush
+   //GO(__NR_bdflush, "n/a");
+ //SY(__NR_bdflush); // (Not yet handled by Valgrind) FAIL;
+
+   // __NR_sysfs arm64 doesn't handle sysfs, use proc.
+   //GO(__NR_sysfs, "n/a");
+ //SY(__NR_sysfs); // (Not yet handled by Valgrind) FAIL;
+
+   // __NR_personality 136
+   GO(__NR_personality, "1s 0m");
+   SY(__NR_personality, x0+0xffffffff); SUCC;
+
+   // __NR_afs_syscall arm64 doesn't implement afs_syscall
+   //GO(__NR_afs_syscall, "ni");
+   //SY(__NR_afs_syscall); FAIL;
+
+   // __NR_setfsuid 138
+   GO(__NR_setfsuid, "1s 0m");
+   SY(__NR_setfsuid, x0); SUCC;  // This syscall has a stupid return value
+
+   // __NR_setfsgid 139
+   GO(__NR_setfsgid, "1s 0m");
+   SY(__NR_setfsgid, x0); SUCC;  // This syscall has a stupid return value
+
+   // __NR__llseek arm64 doesn't implement _llseek
+   //GO(__NR__llseek, "5s 1m");
+   //SY(__NR__llseek, x0, x0, x0, x0, x0); FAIL;
+
+   // __NR_getdents arm64 only has getdents64
+   //GO(__NR_getdents, "3s 1m");
+   //SY(__NR_getdents, x0, x0, x0+1); FAIL;
+
+   // __NR__newselect arm64 doesn't implement _newselect
+   //GO(__NR__newselect, "5s 4m");
+   //SY(__NR__newselect, x0+8, x0+0xffffffff, x0+1, x0+1, x0+1); FAIL;
+
+   // __NR_flock 143
+   GO(__NR_flock, "2s 0m");
+   SY(__NR_flock, x0, x0); FAIL;
+
+   // __NR_msync 144
+   GO(__NR_msync, "3s 1m");
+   SY(__NR_msync, x0, x0+1, x0); FAIL;
+
+   // __NR_readv 145
+   GO(__NR_readv, "3s 1m");
+   SY(__NR_readv, x0, x0, x0+1); FAIL;
+
+   // __NR_writev 146
+   GO(__NR_writev, "3s 1m");
+   SY(__NR_writev, x0, x0, x0+1); FAIL;
+
+   // __NR_getsid 147
+   GO(__NR_getsid, "1s 0m");
+   SY(__NR_getsid, x0-1); FAIL;
+
+   // __NR_fdatasync 148
+   GO(__NR_fdatasync, "1s 0m");
+   SY(__NR_fdatasync, x0-1); FAIL;
+
+   // __NR__sysctl arm64 doesn't implement sysctl, use /proc
+   //GO(__NR__sysctl, "1s 1m");
+   //SY(__NR__sysctl, x0); FAIL;
+
+   // __NR_mlock 150
+   GO(__NR_mlock, "2s 0m");
+   SY(__NR_mlock, x0, x0+1); FAIL;
+
+   // __NR_munlock 151
+   GO(__NR_munlock, "2s 0m");
+   SY(__NR_munlock, x0, x0+1); FAIL;
+
+   // __NR_mlockall 152
+   GO(__NR_mlockall, "1s 0m");
+   SY(__NR_mlockall, x0-1); FAIL;
+
+   // __NR_munlockall 153
+   GO(__NR_munlockall, "0s 0m");
+   SY(__NR_munlockall); SUCC_OR_FAILx(EPERM);
+
+   // __NR_sched_setparam 154
+   GO(__NR_sched_setparam, "2s 1m");
+   SY(__NR_sched_setparam, x0, x0); FAIL;
+
+   // __NR_sched_getparam 155
+   GO(__NR_sched_getparam, "2s 1m");
+   SY(__NR_sched_getparam, x0, x0); FAIL;
+
+   // __NR_sched_setscheduler 156
+   GO(__NR_sched_setscheduler, "3s 1m");
+   SY(__NR_sched_setscheduler, x0-1, x0, x0+1); FAIL;
+
+   // __NR_sched_getscheduler 157
+   GO(__NR_sched_getscheduler, "1s 0m");
+   SY(__NR_sched_getscheduler, x0-1); FAIL;
+
+   // __NR_sched_yield 158
+   GO(__NR_sched_yield, "0s 0m");
+   SY(__NR_sched_yield); SUCC;
+
+   // __NR_sched_get_priority_max 159
+   GO(__NR_sched_get_priority_max, "1s 0m");
+   SY(__NR_sched_get_priority_max, x0-1); FAIL;
+
+   // __NR_sched_get_priority_min 160
+   GO(__NR_sched_get_priority_min, "1s 0m");
+   SY(__NR_sched_get_priority_min, x0-1); FAIL;
+
+   // __NR_sched_rr_get_interval 161
+   GO(__NR_sched_rr_get_interval, "n/a");
+ //SY(__NR_sched_rr_get_interval); // (Not yet handled by Valgrind) FAIL;
+
+   // __NR_nanosleep 162
+   GO(__NR_nanosleep, "2s 2m");
+   SY(__NR_nanosleep, x0, x0+1); FAIL;
+
+   // __NR_mremap 163
+   GO(__NR_mremap, "5s 0m");
+   SY(__NR_mremap, x0+1, x0, x0, x0+MREMAP_FIXED, x0); FAILx(EINVAL);
+
+   // __NR_setresuid 164
+   GO(__NR_setresuid, "3s 0m");
+   SY(__NR_setresuid, x0, x0, x0); FAIL;
+
+   // __NR_getresuid 165
+   GO(__NR_getresuid, "3s 3m");
+   SY(__NR_getresuid, x0, x0, x0); FAIL;
+
+   // __NR_vm86 arm64 doesn't implement vm86
+   //GO(__NR_vm86, "n/a");
+   // (will probably never be handled by Valgrind)
+
+   // __NR_query_module arm64 doesn't implement query_module
+   //GO(__NR_query_module, "ni");
+   //SY(__NR_query_module); FAIL;
+
+   // __NR_poll arm64 only has ppoll
+   //GO(__NR_poll, "3s 1m");
+   //SY(__NR_poll, x0, x0+1, x0); FAIL;
+
+   // __NR_nfsservctl 169
+   GO(__NR_nfsservctl, "n/a");
+ //SY(__NR_nfsservctl); // (Not yet handled by Valgrind) FAIL;
+
+   // __NR_setresgid 170
+   GO(__NR_setresgid, "3s 0m");
+   SY(__NR_setresgid, x0, x0, x0); FAIL;
+
+   // __NR_getresgid 171
+   GO(__NR_getresgid, "3s 3m");
+   SY(__NR_getresgid, x0, x0, x0); FAIL;
+
+   // __NR_prctl 172
+   GO(__NR_prctl, "5s 0m");
+   SY(__NR_prctl, x0, x0, x0, x0, x0); FAIL;
+
+   // __NR_rt_sigreturn 173
+   GO(__NR_rt_sigreturn, "n/a");
+ //SY(__NR_rt_sigreturn); // (Not yet handled by Valgrind) FAIL;
+
+   // __NR_rt_sigaction 174
+   GO(__NR_rt_sigaction, "4s 4m");
+   SY(__NR_rt_sigaction, x0, x0+&px[2], x0+&px[2], x0); FAIL;
+
+   // __NR_rt_sigprocmask 175
+   GO(__NR_rt_sigprocmask, "4s 2m");
+   SY(__NR_rt_sigprocmask, x0, x0+1, x0+1, x0); FAIL;
+
+   // __NR_rt_sigpending 176
+   GO(__NR_rt_sigpending, "2s 1m");
+   SY(__NR_rt_sigpending, x0, x0+1); FAIL;
+
+   // __NR_rt_sigtimedwait 177
+   GO(__NR_rt_sigtimedwait, "4s 3m");
+   SY(__NR_rt_sigtimedwait, x0+1, x0+1, x0+1, x0); FAIL;
+
+   // __NR_rt_sigqueueinfo 178
+   GO(__NR_rt_sigqueueinfo, "3s 1m");
+   SY(__NR_rt_sigqueueinfo, x0, x0+1, x0); FAIL;
+
+   // __NR_rt_sigsuspend 179
+   GO(__NR_rt_sigsuspend, "ignore");
+   // (I don't know how to test this...)
+
+   // __NR_pread64 180
+   GO(__NR_pread64, "5s 1m");
+   SY(__NR_pread64, x0, x0, x0+1, x0, x0); FAIL;
+
+   // __NR_pwrite64 181
+   GO(__NR_pwrite64, "5s 1m");
+   SY(__NR_pwrite64, x0, x0, x0+1, x0, x0); FAIL;
+
+   // __NR_chown arm64 only has chownat
+   //GO(__NR_chown, "3s 1m");
+   //SY(__NR_chown, x0, x0, x0); FAIL;
+
+   // __NR_getcwd 183
+   GO(__NR_getcwd, "2s 1m");
+   SY(__NR_getcwd, x0, x0+1); FAIL;
+
+   // __NR_capget 184
+   GO(__NR_capget, "2s 2m");
+   SY(__NR_capget, x0, x0+1); FAIL;
+
+   // __NR_capset 185
+   GO(__NR_capset, "2s 2m");
+   SY(__NR_capset, x0, x0); FAIL;
+
+   // __NR_sigaltstack 186
+   {
+      struct our_sigaltstack {
+              void *ss_sp;
+              int ss_flags;
+              size_t ss_size;
+      } ss;
+      ss.ss_sp     = NULL;
+      ss.ss_flags  = 0;
+      ss.ss_size   = 0;
+      VALGRIND_MAKE_MEM_NOACCESS(& ss, sizeof(struct our_sigaltstack));
+      GO(__NR_sigaltstack, "2s 2m");
+      SY(__NR_sigaltstack, x0+&ss, x0+&ss); SUCC;
+   }
+
+   // __NR_sendfile 187
+   GO(__NR_sendfile, "4s 1m");
+   SY(__NR_sendfile, x0, x0, x0+1, x0); FAIL;
+
+   // __NR_getpmsg arm64 doesn't implement getpmsg
+   // Could do 5s 4m with more effort, but I can't be bothered for this
+   // crappy non-standard syscall.
+   //GO(__NR_getpmsg, "5s 0m");
+   //SY(__NR_getpmsg, x0, x0, x0, x0); FAIL;
+
+   // __NR_putpmsg arm64 doesn't implement putpmsg
+   // Could do 5s 2m with more effort, but I can't be bothered for this
+   // crappy non-standard syscall.
+   //GO(__NR_putpmsg, "5s 0m");
+   //SY(__NR_putpmsg, x0, x0, x0, x0, x0); FAIL;
+
+   // __NR_vfork arm64 only has clone
+   //GO(__NR_vfork, "other");
+   // (sse scalar_vfork.c)
+
+   // __NR_ugetrlimit arm64 only has getrlimit and prlimit64
+   //GO(__NR_ugetrlimit, "2s 1m");
+   //SY(__NR_ugetrlimit, x0, x0); FAIL;
+
+   // __NR_mmap2 arm64 doesn't implement mmap2
+   //GO(__NR_mmap2, "6s 0m");
+   //SY(__NR_mmap2, x0, x0, x0, x0, x0-1, x0); FAIL;
+
+   // __NR_truncate64 arm64 just has truncate
+   //GO(__NR_truncate64, "3s 1m");
+   //SY(__NR_truncate64, x0, x0, x0); FAIL;
+
+   // __NR_ftruncate64 arm64 just has ftruncate
+   //GO(__NR_ftruncate64, "3s 0m");
+   //SY(__NR_ftruncate64, x0, x0, x0); FAIL;
+
+   // __NR_stat64 arm64 doesn't implement stat64
+   //GO(__NR_stat64, "2s 2m");
+   //SY(__NR_stat64, x0, x0); FAIL;
+
+   // __NR_lstat64 196
+   //GO(__NR_lstat64, "2s 2m");
+   //SY(__NR_lstat64, x0, x0); FAIL;
+
+   // __NR_fstat64 197
+   //GO(__NR_fstat64, "2s 1m");
+   //SY(__NR_fstat64, x0, x0); FAIL;
+
+   // __NR_lchown32 198
+   //GO(__NR_lchown32, "3s 1m");
+   //SY(__NR_lchown32, x0, x0, x0); FAIL;
+
+   // __NR_getuid32 199
+   //GO(__NR_getuid32, "0s 0m");
+   //SY(__NR_getuid32); SUCC;
+
+   // __NR_getgid32 200
+   //GO(__NR_getgid32, "0s 0m");
+   //SY(__NR_getgid32); SUCC;
+
+   // __NR_geteuid32 201
+   //GO(__NR_geteuid32, "0s 0m");
+   //SY(__NR_geteuid32); SUCC;
+
+   // __NR_getegid32 202
+   //GO(__NR_getegid32, "0s 0m");
+   //SY(__NR_getegid32); SUCC;
+
+   // __NR_setreuid32 203
+   //GO(__NR_setreuid32, "2s 0m");
+   //SY(__NR_setreuid32, x0, x0); FAIL;
+
+   // __NR_setregid32 204
+   //GO(__NR_setregid32, "2s 0m");
+   //SY(__NR_setregid32, x0, x0); FAIL;
+
+   // __NR_getgroups32 205
+   //GO(__NR_getgroups32, "2s 1m");
+   //SY(__NR_getgroups32, x0+1, x0+1); FAIL;
+
+   // __NR_setgroups32 206
+   //GO(__NR_setgroups32, "2s 1m");
+   //SY(__NR_setgroups32, x0+1, x0+1); FAIL;
+
+   // __NR_fchown32 207
+   //GO(__NR_fchown32, "3s 0m");
+   //SY(__NR_fchown32, x0, x0, x0); FAIL;
+
+   // __NR_setresuid32 208
+   //GO(__NR_setresuid32, "3s 0m");
+   //SY(__NR_setresuid32, x0, x0, x0); FAIL;
+
+   // __NR_getresuid32 209
+   //GO(__NR_getresuid32, "3s 3m");
+   //SY(__NR_getresuid32, x0, x0, x0); FAIL;
+
+   // __NR_setresgid32 210
+   //GO(__NR_setresgid32, "3s 0m");
+   //SY(__NR_setresgid32, x0, x0, x0); FAIL;
+
+   // __NR_getresgid32 211
+   //GO(__NR_getresgid32, "3s 3m");
+   //SY(__NR_getresgid32, x0, x0, x0); FAIL;
+
+   // __NR_chown32 212
+   //GO(__NR_chown32, "3s 1m");
+   //SY(__NR_chown32, x0, x0, x0); FAIL;
+
+   // __NR_setuid32 213
+   //GO(__NR_setuid32, "1s 0m");
+   //SY(__NR_setuid32, x0); FAIL;
+
+   // __NR_setgid32 214
+   //GO(__NR_setgid32, "1s 0m");
+   //SY(__NR_setgid32, x0); FAIL;
+
+   // __NR_setfsuid32 215
+   //GO(__NR_setfsuid32, "1s 0m");
+   //SY(__NR_setfsuid32, x0); SUCC;  // This syscall has a stupid return value
+
+   // __NR_setfsgid32 216
+   //GO(__NR_setfsgid32, "1s 0m");
+   //SY(__NR_setfsgid32, x0); SUCC;  // This syscall has a stupid return value
+
+   // __NR_pivot_root 217
+   GO(__NR_pivot_root, "n/a");
+ //SY(__NR_pivot_root); // (Not yet handled by Valgrind) FAIL;
+
+   // __NR_mincore 218
+   GO(__NR_mincore, "3s 1m");
+   SY(__NR_mincore, x0, x0+40960, x0); FAIL;
+
+   // __NR_madvise 219
+   GO(__NR_madvise, "3s 0m");
+   SY(__NR_madvise, x0, x0+1, x0); FAILx(ENOMEM);
+
+   // __NR_getdents64 220
+   GO(__NR_getdents64, "3s 1m");
+   SY(__NR_getdents64, x0, x0, x0+1); FAIL;
+
+   // __NR_fcntl64 221
+   // As with sys_open(), we don't trigger errors for the 1st two args for
+   // the later ones.
+   // For F_GETFD the 3rd arg is ignored.
+   //GO(__NR_fcntl64, "(GETFD) 2s 0m");
+   //SY(__NR_fcntl64, x0-1, x0+F_GETFD, x0); FAILx(EBADF);
+
+   // For F_DUPFD the 3rd arg is 'arg'
+   //GO(__NR_fcntl64, "(DUPFD) 1s 0m");
+   //SY(__NR_fcntl64, -1, F_DUPFD, x0); FAILx(EBADF);
+
+   // For F_GETLK the 3rd arg is 'lock'.
+   // On x86, this fails w/EBADF.  But on amd64 in 32-bit mode it fails
+   // w/EFAULT.
+   //GO(__NR_fcntl64, "(GETLK) 1s 0m"); 
+   //SY(__NR_fcntl64, -1, +F_GETLK, x0); FAIL; //FAILx(EBADF);
+
+   // 222
+   //GO(222, "ni");
+   //SY(222); FAIL;
+
+   // 223
+   //GO(223, "ni");
+   //SY(223); FAIL;
+
+   // __NR_gettid 224
+   GO(__NR_gettid, "n/a");
+ //SY(__NR_gettid); // (Not yet handled by Valgrind) FAIL;
+
+   // __NR_readahead 225
+   GO(__NR_readahead, "n/a");
+ //SY(__NR_readahead); // (Not yet handled by Valgrind) FAIL;
+
+   // __NR_setxattr 226
+   GO(__NR_setxattr, "5s 3m");
+   SY(__NR_setxattr, x0, x0, x0, x0+1, x0); FAIL;
+
+   // __NR_lsetxattr 227
+   GO(__NR_lsetxattr, "5s 3m");
+   SY(__NR_lsetxattr, x0, x0, x0, x0+1, x0); FAIL;
+
+   // __NR_fsetxattr 228
+   GO(__NR_fsetxattr, "5s 2m");
+   SY(__NR_fsetxattr, x0, x0, x0, x0+1, x0); FAIL;
+
+   // __NR_getxattr 229
+   GO(__NR_getxattr, "4s 3m");
+   SY(__NR_getxattr, x0, x0, x0, x0+1); FAIL;
+
+   // __NR_lgetxattr 230
+   GO(__NR_lgetxattr, "4s 3m");
+   SY(__NR_lgetxattr, x0, x0, x0, x0+1); FAIL;
+
+   // __NR_fgetxattr 231
+   GO(__NR_fgetxattr, "4s 2m");
+   SY(__NR_fgetxattr, x0, x0, x0, x0+1); FAIL;
+
+   // __NR_listxattr 232
+   GO(__NR_listxattr, "3s 2m");
+   SY(__NR_listxattr, x0, x0, x0+1); FAIL;
+
+   // __NR_llistxattr 233
+   GO(__NR_llistxattr, "3s 2m");
+   SY(__NR_llistxattr, x0, x0, x0+1); FAIL;
+
+   // __NR_flistxattr 234
+   GO(__NR_flistxattr, "3s 1m");
+   SY(__NR_flistxattr, x0-1, x0, x0+1); FAIL; /* kernel returns EBADF, but both seem correct */
+
+   // __NR_removexattr 235
+   GO(__NR_removexattr, "2s 2m");
+   SY(__NR_removexattr, x0, x0); FAIL;
+
+   // __NR_lremovexattr 236
+   GO(__NR_lremovexattr, "2s 2m");
+   SY(__NR_lremovexattr, x0, x0); FAIL;
+
+   // __NR_fremovexattr 237
+   GO(__NR_fremovexattr, "2s 1m");
+   SY(__NR_fremovexattr, x0, x0); FAIL;
+
+   // __NR_tkill 238
+   GO(__NR_tkill, "n/a");
+ //SY(__NR_tkill); // (Not yet handled by Valgrind) FAIL;
+
+   // __NR_sendfile64 239
+   //GO(__NR_sendfile64, "4s 1m");
+   //SY(__NR_sendfile64, x0, x0, x0+1, x0); FAIL;
+
+   // __NR_futex 240
+   #ifndef FUTEX_WAIT
+   #define FUTEX_WAIT   0
+   #endif
+   // XXX: again, glibc not doing 6th arg means we have only 5s errors
+   GO(__NR_futex, "5s 2m");
+   SY(__NR_futex, x0+FUTEX_WAIT, x0, x0, x0+1, x0, x0); FAIL;
+
+   // __NR_sched_setaffinity 241
+   GO(__NR_sched_setaffinity, "3s 1m");
+   SY(__NR_sched_setaffinity, x0, x0+1, x0); FAIL;
+
+   // __NR_sched_getaffinity 242
+   GO(__NR_sched_getaffinity, "3s 1m");
+   SY(__NR_sched_getaffinity, x0, x0+1, x0); FAIL;
+
+   // __NR_set_thread_area 243
+   //GO(__NR_set_thread_area, "1s 1m");
+   //SY(__NR_set_thread_area, x0); FAILx(EFAULT);
+
+   // __NR_get_thread_area 244
+   //GO(__NR_get_thread_area, "1s 1m");
+   //SY(__NR_get_thread_area, x0); FAILx(EFAULT);
+
+   // __NR_io_setup 245
+   GO(__NR_io_setup, "2s 1m");
+   SY(__NR_io_setup, x0, x0); FAIL;
+
+   // __NR_io_destroy 246
+   {
+      // jump through hoops to prevent the PRE(io_destroy) wrapper crashing.
+      struct fake_aio_ring {   
+        unsigned        id;     /* kernel internal index number */
+        unsigned        nr;     /* number of io_events */
+        // There are more fields in the real aio_ring, but the 'nr' field is
+        // the only one used by the PRE() wrapper.
+      } ring = { 0, 0 };
+      struct fake_aio_ring* ringptr = &ring;
+      GO(__NR_io_destroy, "1s 0m");
+      SY(__NR_io_destroy, x0+&ringptr); FAIL;
+   }
+
+   // __NR_io_getevents 247
+   GO(__NR_io_getevents, "5s 2m");
+   SY(__NR_io_getevents, x0, x0, x0+1, x0, x0+1); FAIL;
+
+   // __NR_io_submit 248
+   GO(__NR_io_submit, "3s 1m");
+   SY(__NR_io_submit, x0, x0+1, x0); FAIL;
+
+   // __NR_io_cancel 249
+   GO(__NR_io_cancel, "3s 2m");
+   SY(__NR_io_cancel, x0, x0, x0); FAIL;
+
+   // __NR_fadvise64 250
+   GO(__NR_fadvise64, "n/a");
+ //SY(__NR_fadvise64); // (Not yet handled by Valgrind) FAIL;
+
+   // 251
+   //GO(251, "ni");
+   //SY(251); FAIL;
+
+   // __NR_exit_group 252
+   GO(__NR_exit_group, "other");
+   // (see scalar_exit_group.c)
+
+   // __NR_lookup_dcookie 253
+   GO(__NR_lookup_dcookie, "4s 1m");
+   SY(__NR_lookup_dcookie, x0, x0, x0, x0+1); FAIL;
+
+   // __NR_epoll_create arm64 only has epoll_create1
+   //GO(__NR_epoll_create, "1s 0m");
+   //SY(__NR_epoll_create, x0); SUCC_OR_FAIL;
+
+   // __NR_epoll_ctl 255
+   GO(__NR_epoll_ctl, "4s 1m");
+   SY(__NR_epoll_ctl, x0, x0, x0, x0); FAIL;
+
+   // __NR_epoll_wait arm64 only has epoll_pwait
+   //GO(__NR_epoll_wait, "4s 1m");
+   //SY(__NR_epoll_wait, x0, x0, x0+1, x0); FAIL;
+
+   // __NR_remap_file_pages 257
+   GO(__NR_remap_file_pages, "n/a");
+ //SY(__NR_remap_file_pages); // (Not yet handled by Valgrind) FAIL;
+
+   // __NR_set_tid_address 258
+   GO(__NR_set_tid_address, "1s 0m");
+   SY(__NR_set_tid_address, x0); SUCC_OR_FAILx(ENOSYS);
+
+   // __NR_timer_create 259
+   GO(__NR_timer_create, "3s 2m");
+   SY(__NR_timer_create, x0, x0+1, x0); FAIL;
+
+   // __NR_timer_settime (__NR_timer_create+1)
+   GO(__NR_timer_settime, "4s 2m");
+   SY(__NR_timer_settime, x0, x0, x0, x0+1); FAIL;
+
+   // __NR_timer_gettime (__NR_timer_create+2)
+   GO(__NR_timer_gettime, "2s 1m");
+   SY(__NR_timer_gettime, x0, x0); FAIL;
+
+   // __NR_timer_getoverrun (__NR_timer_create+3)
+   GO(__NR_timer_getoverrun, "1s 0m");
+   SY(__NR_timer_getoverrun, x0); FAIL;
+
+   // __NR_timer_delete (__NR_timer_create+4)
+   GO(__NR_timer_delete, "1s 0m");
+   SY(__NR_timer_delete, x0); FAIL;
+
+   // __NR_clock_settime (__NR_timer_create+5)
+   GO(__NR_clock_settime, "2s 1m");
+   SY(__NR_clock_settime, x0, x0);  FAIL; FAIL;
+
+   // __NR_clock_gettime (__NR_timer_create+6)
+   GO(__NR_clock_gettime, "2s 1m");
+   SY(__NR_clock_gettime, x0, x0); FAIL;
+
+   // __NR_clock_getres (__NR_timer_create+7)
+   GO(__NR_clock_getres, "2s 1m");
+   SY(__NR_clock_getres, x0+1, x0+1); FAIL; FAIL;
+
+   // __NR_clock_nanosleep (__NR_timer_create+8)
+   GO(__NR_clock_nanosleep, "n/a");
+ //SY(__NR_clock_nanosleep); // (Not yet handled by Valgrind) FAIL;
+
+   // __NR_statfs64 268
+   //GO(__NR_statfs64, "3s 2m");
+   //SY(__NR_statfs64, x0, x0+1, x0); FAIL;
+
+   // __NR_fstatfs64 269
+   //GO(__NR_fstatfs64, "3s 1m");
+   //SY(__NR_fstatfs64, x0, x0+1, x0); FAIL;
+
+   // __NR_tgkill 270
+   GO(__NR_tgkill, "n/a");
+ //SY(__NR_tgkill); // (Not yet handled by Valgrind) FAIL;
+
+   // __NR_utimes arm64 only has utimensat
+   //GO(__NR_utimes, "2s 2m");
+   //SY(__NR_utimes, x0, x0+1); FAIL;
+
+   // __NR_fadvise64_64 272
+   //GO(__NR_fadvise64_64, "n/a");
+ //SY(__NR_fadvise64_64); // (Not yet handled by Valgrind) FAIL;
+
+   // __NR_vserver 273
+   //GO(__NR_vserver, "ni");
+   //SY(__NR_vserver); FAIL;
+
+   // __NR_mbind 274
+   GO(__NR_mbind, "n/a");
+ //SY(__NR_mbind); // (Not yet handled by Valgrind) FAIL;
+
+   // __NR_get_mempolicy 275
+   GO(__NR_get_mempolicy, "n/a");
+ //SY(__NR_get_mempolicy); // (Not yet handled by Valgrind) FAIL;
+
+   // __NR_set_mempolicy 276
+   GO(__NR_set_mempolicy, "n/a");
+ //SY(__NR_set_mempolicy); // (Not yet handled by Valgrind) FAIL;
+
+   // __NR_mq_open 277
+   GO(__NR_mq_open, "4s 3m");
+   SY(__NR_mq_open, x0, x0+O_CREAT, x0, x0+1); FAIL;
+
+   // __NR_mq_unlink (__NR_mq_open+1)
+   GO(__NR_mq_unlink, "1s 1m");
+   SY(__NR_mq_unlink, x0); FAIL;
+
+   // __NR_mq_timedsend (__NR_mq_open+2)
+   GO(__NR_mq_timedsend, "5s 2m");
+   SY(__NR_mq_timedsend, x0, x0, x0+1, x0, x0+1); FAIL;
+
+   // __NR_mq_timedreceive (__NR_mq_open+3)
+   GO(__NR_mq_timedreceive, "5s 3m");
+   SY(__NR_mq_timedreceive, x0, x0, x0+1, x0+1, x0+1); FAIL;
+  
+   // __NR_mq_notify (__NR_mq_open+4)
+   GO(__NR_mq_notify, "2s 1m");
+   SY(__NR_mq_notify, x0, x0+1); FAIL;
+
+   // __NR_mq_getsetattr (__NR_mq_open+5)
+   GO(__NR_mq_getsetattr, "3s 2m");
+   SY(__NR_mq_getsetattr, x0, x0+1, x0+1); FAIL;
+   
+   // __NR_kexec_load 283
+   GO(__NR_kexec_load, "ni");
+   SY(__NR_kexec_load); FAIL;
+
+   // __NR_epoll_create1 329
+   GO(__NR_epoll_create1, "1s 0m");
+   SY(__NR_epoll_create1, x0); SUCC_OR_FAIL;
+
+   // __NR_process_vm_readv 347
+   GO(__NR_process_vm_readv, "6s 2m");
+   SY(__NR_process_vm_readv, x0, x0, x0+1, x0, x0+1, x0); FAIL;
+
+   // __NR_process_vm_writev 348
+   GO(__NR_process_vm_writev, "6s 2m");
+   SY(__NR_process_vm_writev, x0, x0, x0+1, x0, x0+1, x0); FAIL;
+
+   // no such syscall...
+   GO(9999, "1e");
+   SY(9999); FAIL;
+
+   // __NR_exit 1
+   GO(__NR_exit, "1s 0m");
+   SY(__NR_exit, x0); FAIL;
+
+   assert(0);
+}
+
diff --git a/memcheck/tests/arm64-linux/scalar.h b/memcheck/tests/arm64-linux/scalar.h
new file mode 100644
index 0000000..9008816
--- /dev/null
+++ b/memcheck/tests/arm64-linux/scalar.h
@@ -0,0 +1,62 @@
+/* This is the arm64 variant of memcheck/tests/x86-linux/scalar.h */
+#include "../../../include/vki/vki-scnums-arm64-linux.h"
+
+#include <assert.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <sys/syscall.h>
+#include <sys/stat.h>
+#include <sys/ptrace.h>
+#include <sys/types.h>
+#include <sys/mman.h>
+
+// Since we use vki_unistd.h, we can't include <unistd.h>.  So we have to
+// declare this ourselves.
+extern long int syscall (long int __sysno, ...) __THROW;
+
+// Thorough syscall scalar arg checking.  Also serves as thorough checking
+// for (very) basic syscall use.  Generally not trying to do anything
+// meaningful with the syscalls.
+
+#define GO(__NR_xxx, s) \
+   fprintf(stderr, "-----------------------------------------------------\n"  \
+                   "%3d:%20s %s\n"                                            \
+                   "-----------------------------------------------------\n", \
+                   __NR_xxx, #__NR_xxx, s);
+
+#define SY  res = syscall
+
+#define FAIL  assert(-1 == res);
+#define SUCC  assert(-1 != res);
+#define SUCC_OR_FAIL    /* no test */
+
+#define FAILx(E) \
+   do { \
+      int myerrno = errno; \
+      if (-1 == res) { \
+         if (E == myerrno) { \
+            /* as expected */ \
+         } else { \
+         fprintf(stderr, "Expected error %s (%d), got %d\n", #E, E, myerrno); \
+         exit(1); \
+         } \
+      } else { \
+         fprintf(stderr, "Expected error %s (%d), got success\n", #E, E); \
+         exit(1); \
+      } \
+   } while (0);
+
+#define SUCC_OR_FAILx(E) \
+   do { \
+      int myerrno = errno; \
+      if (-1 == res) { \
+         if (E == myerrno) { \
+            /* as expected */ \
+         } else { \
+         fprintf(stderr, "Expected error %s (%d), got %d\n", #E, E, myerrno); \
+         exit(1); \
+         } \
+      } \
+   } while (0);
diff --git a/memcheck/tests/arm64-linux/scalar.stderr.exp b/memcheck/tests/arm64-linux/scalar.stderr.exp
new file mode 100644
index 0000000..1dc2035
--- /dev/null
+++ b/memcheck/tests/arm64-linux/scalar.stderr.exp
@@ -0,0 +1,2598 @@
+-----------------------------------------------------
+128:__NR_restart_syscall n/a
+-----------------------------------------------------
+-----------------------------------------------------
+ 93:           __NR_exit below
+-----------------------------------------------------
+-----------------------------------------------------
+ 63:           __NR_read 1+3s 1m
+-----------------------------------------------------
+Syscall param (syscallno) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:51)
+
+Syscall param read(fd) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:51)
+
+Syscall param read(buf) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:51)
+
+Syscall param read(count) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:51)
+
+Syscall param read(buf) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:51)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+-----------------------------------------------------
+ 64:          __NR_write 3s 1m
+-----------------------------------------------------
+Syscall param write(fd) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:55)
+
+Syscall param write(buf) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:55)
+
+Syscall param write(count) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:55)
+
+Syscall param write(buf) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:55)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+-----------------------------------------------------
+ 57:          __NR_close 1s 0m
+-----------------------------------------------------
+Syscall param close(fd) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:69)
+
+-----------------------------------------------------
+221:         __NR_execve 3s 1m
+-----------------------------------------------------
+Syscall param execve(filename) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:91)
+
+Syscall param execve(argv) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:91)
+
+Syscall param execve(envp) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:91)
+
+Syscall param execve(filename) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:91)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+-----------------------------------------------------
+ 49:          __NR_chdir 1s 1m
+-----------------------------------------------------
+Syscall param chdir(path) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:95)
+
+Syscall param chdir(path) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:95)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+-----------------------------------------------------
+ 62:          __NR_lseek 3s 0m
+-----------------------------------------------------
+Syscall param lseek(fd) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:123)
+
+Syscall param lseek(offset) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:123)
+
+Syscall param lseek(whence) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:123)
+
+-----------------------------------------------------
+172:         __NR_getpid 0s 0m
+-----------------------------------------------------
+-----------------------------------------------------
+ 40:          __NR_mount 5s 3m
+-----------------------------------------------------
+Syscall param mount(source) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:131)
+
+Syscall param mount(target) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:131)
+
+Syscall param mount(type) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:131)
+
+Syscall param mount(flags) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:131)
+
+Syscall param mount(data) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:131)
+
+Syscall param mount(target) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:131)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+Syscall param mount(type) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:131)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+-----------------------------------------------------
+146:         __NR_setuid 1s 0m
+-----------------------------------------------------
+Syscall param setuid(uid) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:139)
+
+-----------------------------------------------------
+174:         __NR_getuid 0s 0m
+-----------------------------------------------------
+-----------------------------------------------------
+ 81:           __NR_sync 0s 0m
+-----------------------------------------------------
+-----------------------------------------------------
+129:           __NR_kill 2s 0m
+-----------------------------------------------------
+Syscall param kill(pid) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:196)
+
+Syscall param kill(signal) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:196)
+
+-----------------------------------------------------
+ 23:            __NR_dup 1s 0m
+-----------------------------------------------------
+Syscall param dup(oldfd) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:212)
+
+-----------------------------------------------------
+153:          __NR_times 1s 1m
+-----------------------------------------------------
+Syscall param times(buf) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:220)
+
+Syscall param times(buf) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:220)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+-----------------------------------------------------
+214:            __NR_brk 1s 0m
+-----------------------------------------------------
+Syscall param brk(end_data_segment) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:228)
+
+-----------------------------------------------------
+144:         __NR_setgid 1s 0m
+-----------------------------------------------------
+Syscall param setgid(gid) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:232)
+
+-----------------------------------------------------
+176:         __NR_getgid 0s 0m
+-----------------------------------------------------
+-----------------------------------------------------
+175:        __NR_geteuid 0s 0m
+-----------------------------------------------------
+-----------------------------------------------------
+177:        __NR_getegid 0s 0m
+-----------------------------------------------------
+-----------------------------------------------------
+ 89:           __NR_acct 1s 1m
+-----------------------------------------------------
+Syscall param acct(filename) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:252)
+
+Syscall param acct(filename) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:252)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+-----------------------------------------------------
+ 39:        __NR_umount2 2s 1m
+-----------------------------------------------------
+Syscall param umount2(path) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:256)
+
+Syscall param umount2(flags) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:256)
+
+Syscall param umount2(path) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:256)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+-----------------------------------------------------
+ 29:          __NR_ioctl 3s 1m
+-----------------------------------------------------
+Syscall param ioctl(fd) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:265)
+
+Syscall param ioctl(request) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:265)
+
+Syscall param ioctl(arg) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:265)
+
+Syscall param ioctl(TCSET{S,SW,SF}) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:265)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+-----------------------------------------------------
+ 25:          __NR_fcntl (GETFD) 2s 0m
+-----------------------------------------------------
+Syscall param fcntl(fd) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:271)
+
+Syscall param fcntl(cmd) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:271)
+
+-----------------------------------------------------
+ 25:          __NR_fcntl (DUPFD) 1s 0m
+-----------------------------------------------------
+Syscall param fcntl(arg) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:277)
+
+-----------------------------------------------------
+ 25:          __NR_fcntl (GETLK) 1s 0m
+-----------------------------------------------------
+Syscall param fcntl(lock) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:283)
+
+-----------------------------------------------------
+154:        __NR_setpgid 2s 0m
+-----------------------------------------------------
+Syscall param setpgid(pid) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:291)
+
+Syscall param setpgid(pgid) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:291)
+
+-----------------------------------------------------
+166:          __NR_umask 1s 0m
+-----------------------------------------------------
+Syscall param umask(mask) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:303)
+
+-----------------------------------------------------
+ 51:         __NR_chroot 1s 1m
+-----------------------------------------------------
+Syscall param chroot(path) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:307)
+
+Syscall param chroot(path) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:307)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+-----------------------------------------------------
+173:        __NR_getppid 0s 0m
+-----------------------------------------------------
+-----------------------------------------------------
+157:         __NR_setsid 0s 0m
+-----------------------------------------------------
+-----------------------------------------------------
+145:       __NR_setreuid 2s 0m
+-----------------------------------------------------
+Syscall param setreuid(ruid) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:343)
+
+Syscall param setreuid(euid) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:343)
+
+-----------------------------------------------------
+143:       __NR_setregid 2s 0m
+-----------------------------------------------------
+Syscall param setregid(rgid) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:347)
+
+Syscall param setregid(egid) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:347)
+
+-----------------------------------------------------
+161:    __NR_sethostname n/a
+-----------------------------------------------------
+-----------------------------------------------------
+164:      __NR_setrlimit 2s 1m
+-----------------------------------------------------
+Syscall param setrlimit(resource) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:364)
+
+Syscall param setrlimit(rlim) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:364)
+
+Syscall param setrlimit(rlim) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:364)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+-----------------------------------------------------
+163:      __NR_getrlimit 2s 1m
+-----------------------------------------------------
+Syscall param old_getrlimit(resource) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:368)
+
+Syscall param old_getrlimit(rlim) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:368)
+
+Syscall param old_getrlimit(rlim) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:368)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+-----------------------------------------------------
+165:      __NR_getrusage 2s 1m
+-----------------------------------------------------
+Syscall param getrusage(who) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:372)
+
+Syscall param getrusage(usage) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:372)
+
+Syscall param getrusage(usage) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:372)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+-----------------------------------------------------
+169:   __NR_gettimeofday 2s 2m
+-----------------------------------------------------
+Syscall param gettimeofday(tv) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:376)
+
+Syscall param gettimeofday(tz) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:376)
+
+Syscall param gettimeofday(tv) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:376)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+Syscall param gettimeofday(tz) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:376)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+-----------------------------------------------------
+170:   __NR_settimeofday 2s 2m
+-----------------------------------------------------
+Syscall param settimeofday(tv) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:380)
+
+Syscall param settimeofday(tz) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:380)
+
+Syscall param settimeofday(tv) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:380)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+Syscall param settimeofday(tz) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:380)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+-----------------------------------------------------
+158:      __NR_getgroups 2s 1m
+-----------------------------------------------------
+Syscall param getgroups(size) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:384)
+
+Syscall param getgroups(list) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:384)
+
+Syscall param getgroups(list) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:384)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+-----------------------------------------------------
+159:      __NR_setgroups 2s 1m
+-----------------------------------------------------
+Syscall param setgroups(size) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:388)
+
+Syscall param setgroups(list) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:388)
+
+Syscall param setgroups(list) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:388)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+-----------------------------------------------------
+224:         __NR_swapon n/a
+-----------------------------------------------------
+-----------------------------------------------------
+142:         __NR_reboot n/a
+-----------------------------------------------------
+-----------------------------------------------------
+222:           __NR_mmap 1s 1m
+-----------------------------------------------------
+Syscall param mmap(start) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:429)
+
+-----------------------------------------------------
+215:         __NR_munmap 2s 0m
+-----------------------------------------------------
+Syscall param munmap(start) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:434)
+
+Syscall param munmap(length) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:434)
+
+-----------------------------------------------------
+ 45:       __NR_truncate 2s 1m
+-----------------------------------------------------
+Syscall param truncate(path) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:438)
+
+Syscall param truncate(length) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:438)
+
+Syscall param truncate(path) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:438)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+-----------------------------------------------------
+ 46:      __NR_ftruncate 2s 0m
+-----------------------------------------------------
+Syscall param ftruncate(fd) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:442)
+
+Syscall param ftruncate(length) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:442)
+
+-----------------------------------------------------
+ 52:         __NR_fchmod 2s 0m
+-----------------------------------------------------
+Syscall param fchmod(fildes) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:446)
+
+Syscall param fchmod(mode) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:446)
+
+-----------------------------------------------------
+ 55:         __NR_fchown 3s 0m
+-----------------------------------------------------
+Syscall param fchown(fd) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:450)
+
+Syscall param fchown(owner) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:450)
+
+Syscall param fchown(group) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:450)
+
+-----------------------------------------------------
+141:    __NR_getpriority 2s 0m
+-----------------------------------------------------
+Syscall param getpriority(which) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:454)
+
+Syscall param getpriority(who) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:454)
+
+-----------------------------------------------------
+140:    __NR_setpriority 3s 0m
+-----------------------------------------------------
+Syscall param setpriority(which) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:458)
+
+Syscall param setpriority(who) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:458)
+
+Syscall param setpriority(prio) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:458)
+
+-----------------------------------------------------
+ 43:         __NR_statfs 2s 2m
+-----------------------------------------------------
+Syscall param statfs(path) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:466)
+
+Syscall param statfs(buf) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:466)
+
+Syscall param statfs(path) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:466)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+
+More than 100 errors detected.  Subsequent errors
+will still be recorded, but in less detail than before.
+Syscall param statfs(buf) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:466)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+-----------------------------------------------------
+ 44:        __NR_fstatfs 2s 1m
+-----------------------------------------------------
+Syscall param fstatfs(fd) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:470)
+
+Syscall param fstatfs(buf) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:470)
+
+Syscall param fstatfs(buf) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:470)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+-----------------------------------------------------
+116:         __NR_syslog 3s 1m
+-----------------------------------------------------
+Syscall param syslog(type) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:482)
+
+Syscall param syslog(bufp) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:482)
+
+Syscall param syslog(len) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:482)
+
+Syscall param syslog(bufp) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:482)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+-----------------------------------------------------
+103:      __NR_setitimer 3s 2m
+-----------------------------------------------------
+Syscall param setitimer(which) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:486)
+
+Syscall param setitimer(value) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:486)
+
+Syscall param setitimer(ovalue) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:486)
+
+Syscall param setitimer(&value->it_interval) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:486)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+Syscall param setitimer(&value->it_value) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:486)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+Syscall param setitimer(&ovalue->it_interval) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:486)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+Syscall param setitimer(&ovalue->it_value) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:486)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+-----------------------------------------------------
+102:      __NR_getitimer 2s 1m
+-----------------------------------------------------
+Syscall param getitimer(which) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:490)
+
+Syscall param getitimer(value) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:490)
+
+Syscall param getitimer(&value->it_interval) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:490)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+Syscall param getitimer(&value->it_value) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:490)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+-----------------------------------------------------
+ 80:          __NR_fstat 2s 1m
+-----------------------------------------------------
+Syscall param fstat(fd) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:502)
+
+Syscall param fstat(buf) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:502)
+
+Syscall param fstat(buf) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:502)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+-----------------------------------------------------
+ 58:        __NR_vhangup 0s 0m
+-----------------------------------------------------
+-----------------------------------------------------
+260:          __NR_wait4 4s 2m
+-----------------------------------------------------
+Syscall param wait4(pid) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:526)
+
+Syscall param wait4(status) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:526)
+
+Syscall param wait4(options) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:526)
+
+Syscall param wait4(rusage) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:526)
+
+Syscall param wait4(status) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:526)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+Syscall param wait4(rusage) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:526)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+-----------------------------------------------------
+225:        __NR_swapoff n/a
+-----------------------------------------------------
+-----------------------------------------------------
+179:        __NR_sysinfo 1s 1m
+-----------------------------------------------------
+Syscall param sysinfo(info) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:534)
+
+Syscall param sysinfo(info) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:534)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+-----------------------------------------------------
+ 82:          __NR_fsync 1s 0m
+-----------------------------------------------------
+Syscall param fsync(fd) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:545)
+
+-----------------------------------------------------
+220:          __NR_clone 5s 3m
+-----------------------------------------------------
+Syscall param clone(flags) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:556)
+
+Syscall param clone(child_stack) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:556)
+
+Syscall param clone(parent_tidptr) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:556)
+
+Syscall param clone(child_tls) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:556)
+
+Syscall param clone(child_tidptr) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:556)
+
+Syscall param clone(parent_tidptr) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:556)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+-----------------------------------------------------
+162:  __NR_setdomainname n/a
+-----------------------------------------------------
+-----------------------------------------------------
+160:          __NR_uname 1s 1m
+-----------------------------------------------------
+Syscall param uname(buf) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:567)
+
+Syscall param uname(buf) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:567)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+-----------------------------------------------------
+171:       __NR_adjtimex XXX
+-----------------------------------------------------
+-----------------------------------------------------
+226:       __NR_mprotect 3s 0m
+-----------------------------------------------------
+Syscall param mprotect(addr) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:580)
+
+Syscall param mprotect(len) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:580)
+
+Syscall param mprotect(prot) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:580)
+
+-----------------------------------------------------
+105:    __NR_init_module 3s 2m
+-----------------------------------------------------
+Syscall param init_module(umod) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:592)
+
+Syscall param init_module(len) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:592)
+
+Syscall param init_module(uargs) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:592)
+
+Syscall param init_module(umod) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:592)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+Syscall param init_module(uargs) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:592)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+-----------------------------------------------------
+106:  __NR_delete_module n/a
+-----------------------------------------------------
+-----------------------------------------------------
+ 60:       __NR_quotactl 4s 1m
+-----------------------------------------------------
+Syscall param quotactl(cmd) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:604)
+
+Syscall param quotactl(special) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:604)
+
+Syscall param quotactl(id) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:604)
+
+Syscall param quotactl(addr) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:604)
+
+Syscall param quotactl(special) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:604)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+-----------------------------------------------------
+155:        __NR_getpgid 1s 0m
+-----------------------------------------------------
+Syscall param getpgid(pid) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:608)
+
+-----------------------------------------------------
+ 50:         __NR_fchdir 1s 0m
+-----------------------------------------------------
+Syscall param fchdir(fd) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:612)
+
+-----------------------------------------------------
+ 92:    __NR_personality 1s 0m
+-----------------------------------------------------
+Syscall param personality(persona) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:624)
+
+-----------------------------------------------------
+151:       __NR_setfsuid 1s 0m
+-----------------------------------------------------
+Syscall param setfsuid(uid) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:632)
+
+-----------------------------------------------------
+152:       __NR_setfsgid 1s 0m
+-----------------------------------------------------
+Syscall param setfsgid(gid) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:636)
+
+-----------------------------------------------------
+ 32:          __NR_flock 2s 0m
+-----------------------------------------------------
+Syscall param flock(fd) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:652)
+
+Syscall param flock(operation) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:652)
+
+-----------------------------------------------------
+227:          __NR_msync 3s 1m
+-----------------------------------------------------
+Syscall param msync(start) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:656)
+
+Syscall param msync(length) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:656)
+
+Syscall param msync(flags) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:656)
+
+Syscall param msync(start) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:656)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+-----------------------------------------------------
+ 65:          __NR_readv 3s 1m
+-----------------------------------------------------
+Syscall param readv(fd) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:660)
+
+Syscall param readv(vector) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:660)
+
+Syscall param readv(count) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:660)
+
+Syscall param readv(vector) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:660)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+-----------------------------------------------------
+ 66:         __NR_writev 3s 1m
+-----------------------------------------------------
+Syscall param writev(fd) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:664)
+
+Syscall param writev(vector) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:664)
+
+Syscall param writev(count) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:664)
+
+Syscall param writev(vector) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:664)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+-----------------------------------------------------
+156:         __NR_getsid 1s 0m
+-----------------------------------------------------
+Syscall param getsid(pid) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:668)
+
+-----------------------------------------------------
+ 83:      __NR_fdatasync 1s 0m
+-----------------------------------------------------
+Syscall param fdatasync(fd) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:672)
+
+-----------------------------------------------------
+228:          __NR_mlock 2s 0m
+-----------------------------------------------------
+Syscall param mlock(addr) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:680)
+
+Syscall param mlock(len) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:680)
+
+-----------------------------------------------------
+229:        __NR_munlock 2s 0m
+-----------------------------------------------------
+Syscall param munlock(addr) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:684)
+
+Syscall param munlock(len) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:684)
+
+-----------------------------------------------------
+230:       __NR_mlockall 1s 0m
+-----------------------------------------------------
+Syscall param mlockall(flags) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:688)
+
+-----------------------------------------------------
+231:     __NR_munlockall 0s 0m
+-----------------------------------------------------
+-----------------------------------------------------
+118: __NR_sched_setparam 2s 1m
+-----------------------------------------------------
+Syscall param sched_setparam(pid) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:696)
+
+Syscall param sched_setparam(p) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:696)
+
+Syscall param sched_setparam(p) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:696)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+-----------------------------------------------------
+121: __NR_sched_getparam 2s 1m
+-----------------------------------------------------
+Syscall param sched_getparam(pid) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:700)
+
+Syscall param sched_getparam(p) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:700)
+
+Syscall param sched_getparam(p) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:700)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+-----------------------------------------------------
+119:__NR_sched_setscheduler 3s 1m
+-----------------------------------------------------
+Syscall param sched_setscheduler(pid) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:704)
+
+Syscall param sched_setscheduler(policy) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:704)
+
+Syscall param sched_setscheduler(p) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:704)
+
+Syscall param sched_setscheduler(p) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:704)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+-----------------------------------------------------
+120:__NR_sched_getscheduler 1s 0m
+-----------------------------------------------------
+Syscall param sched_getscheduler(pid) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:708)
+
+-----------------------------------------------------
+124:    __NR_sched_yield 0s 0m
+-----------------------------------------------------
+-----------------------------------------------------
+125:__NR_sched_get_priority_max 1s 0m
+-----------------------------------------------------
+Syscall param sched_get_priority_max(policy) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:716)
+
+-----------------------------------------------------
+126:__NR_sched_get_priority_min 1s 0m
+-----------------------------------------------------
+Syscall param sched_get_priority_min(policy) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:720)
+
+-----------------------------------------------------
+127:__NR_sched_rr_get_interval n/a
+-----------------------------------------------------
+-----------------------------------------------------
+101:      __NR_nanosleep 2s 2m
+-----------------------------------------------------
+Syscall param nanosleep(req) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:728)
+
+Syscall param nanosleep(rem) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:728)
+
+Syscall param nanosleep(req) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:728)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+Syscall param nanosleep(rem) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:728)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+-----------------------------------------------------
+216:         __NR_mremap 5s 0m
+-----------------------------------------------------
+Syscall param mremap(old_addr) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:732)
+
+Syscall param mremap(old_size) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:732)
+
+Syscall param mremap(new_size) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:732)
+
+Syscall param mremap(flags) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:732)
+
+Syscall param mremap(new_addr) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:732)
+
+-----------------------------------------------------
+147:      __NR_setresuid 3s 0m
+-----------------------------------------------------
+Syscall param setresuid(ruid) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:736)
+
+Syscall param setresuid(euid) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:736)
+
+Syscall param setresuid(suid) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:736)
+
+-----------------------------------------------------
+148:      __NR_getresuid 3s 3m
+-----------------------------------------------------
+Syscall param getresuid(ruid) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:740)
+
+Syscall param getresuid(euid) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:740)
+
+Syscall param getresuid(suid) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:740)
+
+Syscall param getresuid(ruid) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:740)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+Syscall param getresuid(euid) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:740)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+Syscall param getresuid(suid) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:740)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+-----------------------------------------------------
+ 42:     __NR_nfsservctl n/a
+-----------------------------------------------------
+-----------------------------------------------------
+149:      __NR_setresgid 3s 0m
+-----------------------------------------------------
+Syscall param setresgid(rgid) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:760)
+
+Syscall param setresgid(egid) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:760)
+
+Syscall param setresgid(sgid) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:760)
+
+-----------------------------------------------------
+150:      __NR_getresgid 3s 3m
+-----------------------------------------------------
+Syscall param getresgid(rgid) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:764)
+
+Syscall param getresgid(egid) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:764)
+
+Syscall param getresgid(sgid) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:764)
+
+Syscall param getresgid(rgid) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:764)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+Syscall param getresgid(egid) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:764)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+Syscall param getresgid(sgid) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:764)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+-----------------------------------------------------
+167:          __NR_prctl 5s 0m
+-----------------------------------------------------
+Syscall param prctl(option) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:768)
+
+Syscall param prctl(arg2) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:768)
+
+Syscall param prctl(arg3) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:768)
+
+Syscall param prctl(arg4) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:768)
+
+Syscall param prctl(arg5) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:768)
+
+-----------------------------------------------------
+139:   __NR_rt_sigreturn n/a
+-----------------------------------------------------
+-----------------------------------------------------
+134:   __NR_rt_sigaction 4s 4m
+-----------------------------------------------------
+Syscall param rt_sigaction(signum) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:776)
+
+Syscall param rt_sigaction(act) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:776)
+
+Syscall param rt_sigaction(oldact) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:776)
+
+Syscall param rt_sigaction(sigsetsize) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:776)
+
+Syscall param rt_sigaction(act->sa_handler) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:776)
+ Address 0x........ is 8 bytes after a block of size 8 alloc'd
+   at 0x........: malloc (vg_replace_malloc.c:...)
+   by 0x........: main (scalar.c:30)
+
+Syscall param rt_sigaction(act->sa_mask) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:776)
+ Address 0x........ is 24 bytes after a block of size 16 in arena "client"
+
+Syscall param rt_sigaction(act->sa_flags) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:776)
+ Address 0x........ is 16 bytes after a block of size 8 alloc'd
+   at 0x........: malloc (vg_replace_malloc.c:...)
+   by 0x........: main (scalar.c:30)
+
+Syscall param rt_sigaction(oldact) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:776)
+ Address 0x........ is 8 bytes after a block of size 8 alloc'd
+   at 0x........: malloc (vg_replace_malloc.c:...)
+   by 0x........: main (scalar.c:30)
+
+-----------------------------------------------------
+135: __NR_rt_sigprocmask 4s 2m
+-----------------------------------------------------
+Syscall param rt_sigprocmask(how) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:780)
+
+Syscall param rt_sigprocmask(set) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:780)
+
+Syscall param rt_sigprocmask(oldset) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:780)
+
+Syscall param rt_sigprocmask(sigsetsize) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:780)
+
+Syscall param rt_sigprocmask(set) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:780)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+Syscall param rt_sigprocmask(oldset) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:780)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+-----------------------------------------------------
+136:  __NR_rt_sigpending 2s 1m
+-----------------------------------------------------
+Syscall param rt_sigpending(set) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:784)
+
+Syscall param rt_sigpending(sigsetsize) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:784)
+
+Syscall param rt_sigpending(set) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:784)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+-----------------------------------------------------
+137:__NR_rt_sigtimedwait 4s 3m
+-----------------------------------------------------
+Syscall param rt_sigtimedwait(set) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:788)
+
+Syscall param rt_sigtimedwait(info) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:788)
+
+Syscall param rt_sigtimedwait(timeout) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:788)
+
+Syscall param rt_sigtimedwait(sigsetsize) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:788)
+
+Syscall param rt_sigtimedwait(set) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:788)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+Syscall param rt_sigtimedwait(info) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:788)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+Syscall param rt_sigtimedwait(timeout) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:788)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+-----------------------------------------------------
+138:__NR_rt_sigqueueinfo 3s 1m
+-----------------------------------------------------
+Syscall param rt_sigqueueinfo(pid) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:792)
+
+Syscall param rt_sigqueueinfo(sig) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:792)
+
+Syscall param rt_sigqueueinfo(uinfo) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:792)
+
+Syscall param rt_sigqueueinfo(uinfo) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:792)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+-----------------------------------------------------
+133:  __NR_rt_sigsuspend ignore
+-----------------------------------------------------
+-----------------------------------------------------
+ 67:        __NR_pread64 5s 1m
+-----------------------------------------------------
+Syscall param pread64(fd) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:800)
+
+Syscall param pread64(buf) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:800)
+
+Syscall param pread64(count) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:800)
+
+Syscall param pread64(offset) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:800)
+
+Syscall param pread64(buf) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:800)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+-----------------------------------------------------
+ 68:       __NR_pwrite64 5s 1m
+-----------------------------------------------------
+Syscall param pwrite64(fd) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:804)
+
+Syscall param pwrite64(buf) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:804)
+
+Syscall param pwrite64(count) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:804)
+
+Syscall param pwrite64(offset) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:804)
+
+Syscall param pwrite64(buf) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:804)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+-----------------------------------------------------
+ 17:         __NR_getcwd 2s 1m
+-----------------------------------------------------
+Syscall param getcwd(buf) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:812)
+
+Syscall param getcwd(size) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:812)
+
+Syscall param getcwd(buf) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:812)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+-----------------------------------------------------
+ 90:         __NR_capget 2s 2m
+-----------------------------------------------------
+Syscall param capget(header) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:816)
+
+Syscall param capget(data) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:816)
+
+Syscall param capget(header) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:816)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+Syscall param capget(data) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:816)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+-----------------------------------------------------
+ 91:         __NR_capset 2s 2m
+-----------------------------------------------------
+Syscall param capset(header) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:820)
+
+Syscall param capset(data) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:820)
+
+Syscall param capset(header) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:820)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+Syscall param capset(data) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:820)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+-----------------------------------------------------
+132:    __NR_sigaltstack 2s 2m
+-----------------------------------------------------
+Syscall param sigaltstack(ss) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:834)
+
+Syscall param sigaltstack(oss) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:834)
+
+Syscall param sigaltstack(ss) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:834)
+ Address 0x........ is on thread 1's stack
+ in frame #1, created by main (scalar.c:28)
+
+Syscall param sigaltstack(oss) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:834)
+ Address 0x........ is on thread 1's stack
+ in frame #1, created by main (scalar.c:28)
+
+-----------------------------------------------------
+ 71:       __NR_sendfile 4s 1m
+-----------------------------------------------------
+Syscall param sendfile(out_fd) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:839)
+
+Syscall param sendfile(in_fd) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:839)
+
+Syscall param sendfile(offset) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:839)
+
+Syscall param sendfile(count) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:839)
+
+Syscall param sendfile(offset) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:839)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+-----------------------------------------------------
+ 41:     __NR_pivot_root n/a
+-----------------------------------------------------
+-----------------------------------------------------
+232:        __NR_mincore 3s 1m
+-----------------------------------------------------
+Syscall param mincore(start) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:967)
+
+Syscall param mincore(length) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:967)
+
+Syscall param mincore(vec) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:967)
+
+Syscall param mincore(vec) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:967)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+-----------------------------------------------------
+233:        __NR_madvise 3s 0m
+-----------------------------------------------------
+Syscall param madvise(start) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:971)
+
+Syscall param madvise(length) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:971)
+
+Syscall param madvise(advice) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:971)
+
+-----------------------------------------------------
+ 61:     __NR_getdents64 3s 1m
+-----------------------------------------------------
+Syscall param getdents64(fd) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:975)
+
+Syscall param getdents64(dirp) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:975)
+
+Syscall param getdents64(count) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:975)
+
+Syscall param getdents64(dirp) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:975)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+-----------------------------------------------------
+178:         __NR_gettid n/a
+-----------------------------------------------------
+-----------------------------------------------------
+213:      __NR_readahead n/a
+-----------------------------------------------------
+-----------------------------------------------------
+  5:       __NR_setxattr 5s 3m
+-----------------------------------------------------
+Syscall param setxattr(path) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1012)
+
+Syscall param setxattr(name) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1012)
+
+Syscall param setxattr(value) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1012)
+
+Syscall param setxattr(size) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1012)
+
+Syscall param setxattr(flags) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1012)
+
+Syscall param setxattr(path) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:1012)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+Syscall param setxattr(name) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:1012)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+Syscall param setxattr(value) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:1012)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+-----------------------------------------------------
+  6:      __NR_lsetxattr 5s 3m
+-----------------------------------------------------
+Syscall param lsetxattr(path) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1016)
+
+Syscall param lsetxattr(name) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1016)
+
+Syscall param lsetxattr(value) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1016)
+
+Syscall param lsetxattr(size) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1016)
+
+Syscall param lsetxattr(flags) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1016)
+
+Syscall param lsetxattr(path) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:1016)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+Syscall param lsetxattr(name) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:1016)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+Syscall param lsetxattr(value) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:1016)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+-----------------------------------------------------
+  7:      __NR_fsetxattr 5s 2m
+-----------------------------------------------------
+Syscall param fsetxattr(fd) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1020)
+
+Syscall param fsetxattr(name) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1020)
+
+Syscall param fsetxattr(value) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1020)
+
+Syscall param fsetxattr(size) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1020)
+
+Syscall param fsetxattr(flags) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1020)
+
+Syscall param fsetxattr(name) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:1020)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+Syscall param fsetxattr(value) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:1020)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+-----------------------------------------------------
+  8:       __NR_getxattr 4s 3m
+-----------------------------------------------------
+Syscall param getxattr(path) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1024)
+
+Syscall param getxattr(name) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1024)
+
+Syscall param getxattr(value) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1024)
+
+Syscall param getxattr(size) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1024)
+
+Syscall param getxattr(path) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:1024)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+Syscall param getxattr(name) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:1024)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+Syscall param getxattr(value) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:1024)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+-----------------------------------------------------
+  9:      __NR_lgetxattr 4s 3m
+-----------------------------------------------------
+Syscall param lgetxattr(path) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1028)
+
+Syscall param lgetxattr(name) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1028)
+
+Syscall param lgetxattr(value) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1028)
+
+Syscall param lgetxattr(size) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1028)
+
+Syscall param lgetxattr(path) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:1028)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+Syscall param lgetxattr(name) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:1028)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+Syscall param lgetxattr(value) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:1028)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+-----------------------------------------------------
+ 10:      __NR_fgetxattr 4s 2m
+-----------------------------------------------------
+Syscall param fgetxattr(fd) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1032)
+
+Syscall param fgetxattr(name) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1032)
+
+Syscall param fgetxattr(value) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1032)
+
+Syscall param fgetxattr(size) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1032)
+
+Syscall param fgetxattr(name) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:1032)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+Syscall param fgetxattr(value) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:1032)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+-----------------------------------------------------
+ 11:      __NR_listxattr 3s 2m
+-----------------------------------------------------
+Syscall param listxattr(path) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1036)
+
+Syscall param listxattr(list) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1036)
+
+Syscall param listxattr(size) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1036)
+
+Syscall param listxattr(path) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:1036)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+Syscall param listxattr(list) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:1036)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+-----------------------------------------------------
+ 12:     __NR_llistxattr 3s 2m
+-----------------------------------------------------
+Syscall param llistxattr(path) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1040)
+
+Syscall param llistxattr(list) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1040)
+
+Syscall param llistxattr(size) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1040)
+
+Syscall param llistxattr(path) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:1040)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+Syscall param llistxattr(list) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:1040)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+-----------------------------------------------------
+ 13:     __NR_flistxattr 3s 1m
+-----------------------------------------------------
+Syscall param flistxattr(fd) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1044)
+
+Syscall param flistxattr(list) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1044)
+
+Syscall param flistxattr(size) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1044)
+
+Syscall param flistxattr(list) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:1044)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+-----------------------------------------------------
+ 14:    __NR_removexattr 2s 2m
+-----------------------------------------------------
+Syscall param removexattr(path) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1048)
+
+Syscall param removexattr(name) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1048)
+
+Syscall param removexattr(path) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:1048)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+Syscall param removexattr(name) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:1048)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+-----------------------------------------------------
+ 15:   __NR_lremovexattr 2s 2m
+-----------------------------------------------------
+Syscall param lremovexattr(path) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1052)
+
+Syscall param lremovexattr(name) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1052)
+
+Syscall param lremovexattr(path) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:1052)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+Syscall param lremovexattr(name) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:1052)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+-----------------------------------------------------
+ 16:   __NR_fremovexattr 2s 1m
+-----------------------------------------------------
+Syscall param fremovexattr(fd) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1056)
+
+Syscall param fremovexattr(name) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1056)
+
+Syscall param fremovexattr(name) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:1056)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+-----------------------------------------------------
+130:          __NR_tkill n/a
+-----------------------------------------------------
+-----------------------------------------------------
+ 98:          __NR_futex 5s 2m
+-----------------------------------------------------
+Syscall param futex(futex) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1072)
+
+Syscall param futex(op) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1072)
+
+Syscall param futex(val) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1072)
+
+Syscall param futex(utime) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1072)
+
+Syscall param futex(futex) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:1072)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+Syscall param futex(timeout) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:1072)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+-----------------------------------------------------
+122:__NR_sched_setaffinity 3s 1m
+-----------------------------------------------------
+Syscall param sched_setaffinity(pid) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1076)
+
+Syscall param sched_setaffinity(len) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1076)
+
+Syscall param sched_setaffinity(mask) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1076)
+
+Syscall param sched_setaffinity(mask) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:1076)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+-----------------------------------------------------
+123:__NR_sched_getaffinity 3s 1m
+-----------------------------------------------------
+Syscall param sched_getaffinity(pid) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1080)
+
+Syscall param sched_getaffinity(len) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1080)
+
+Syscall param sched_getaffinity(mask) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1080)
+
+Syscall param sched_getaffinity(mask) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:1080)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+-----------------------------------------------------
+  0:       __NR_io_setup 2s 1m
+-----------------------------------------------------
+Syscall param io_setup(nr_events) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1092)
+
+Syscall param io_setup(ctxp) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1092)
+
+Syscall param io_setup(ctxp) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:1092)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+-----------------------------------------------------
+  1:     __NR_io_destroy 1s 0m
+-----------------------------------------------------
+Syscall param io_destroy(ctx) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1105)
+
+-----------------------------------------------------
+  4:   __NR_io_getevents 5s 2m
+-----------------------------------------------------
+Syscall param io_getevents(ctx_id) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1110)
+
+Syscall param io_getevents(min_nr) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1110)
+
+Syscall param io_getevents(nr) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1110)
+
+Syscall param io_getevents(events) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1110)
+
+Syscall param io_getevents(timeout) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1110)
+
+Syscall param io_getevents(events) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:1110)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+Syscall param io_getevents(timeout) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:1110)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+-----------------------------------------------------
+  2:      __NR_io_submit 3s 1m
+-----------------------------------------------------
+Syscall param io_submit(ctx_id) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1114)
+
+Syscall param io_submit(nr) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1114)
+
+Syscall param io_submit(iocbpp) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1114)
+
+Syscall param io_submit(iocbpp) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:1114)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+-----------------------------------------------------
+  3:      __NR_io_cancel 3s 2m
+-----------------------------------------------------
+Syscall param io_cancel(ctx_id) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1118)
+
+Syscall param io_cancel(iocb) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1118)
+
+Syscall param io_cancel(result) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1118)
+
+Syscall param io_cancel(iocb) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:1118)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+Syscall param io_cancel(result) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:1118)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+-----------------------------------------------------
+223:      __NR_fadvise64 n/a
+-----------------------------------------------------
+-----------------------------------------------------
+ 94:     __NR_exit_group other
+-----------------------------------------------------
+-----------------------------------------------------
+ 18: __NR_lookup_dcookie 4s 1m
+-----------------------------------------------------
+Syscall param lookup_dcookie(cookie) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1134)
+
+Syscall param lookup_dcookie(buf) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1134)
+
+Syscall param lookup_dcookie(len) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1134)
+
+-----------------------------------------------------
+ 21:      __NR_epoll_ctl 4s 1m
+-----------------------------------------------------
+Syscall param epoll_ctl(epfd) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1142)
+
+Syscall param epoll_ctl(op) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1142)
+
+Syscall param epoll_ctl(fd) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1142)
+
+Syscall param epoll_ctl(event) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1142)
+
+Syscall param epoll_ctl(event) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:1142)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+-----------------------------------------------------
+234:__NR_remap_file_pages n/a
+-----------------------------------------------------
+-----------------------------------------------------
+ 96:__NR_set_tid_address 1s 0m
+-----------------------------------------------------
+Syscall param set_tid_address(tidptr) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1154)
+
+-----------------------------------------------------
+107:   __NR_timer_create 3s 2m
+-----------------------------------------------------
+Syscall param timer_create(clockid) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1158)
+
+Syscall param timer_create(evp) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1158)
+
+Syscall param timer_create(timerid) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1158)
+
+Syscall param timer_create(evp.sigev_value) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:1158)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+Syscall param timer_create(evp.sigev_signo) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:1158)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+Syscall param timer_create(evp.sigev_notify) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:1158)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+Syscall param timer_create(timerid) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:1158)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+-----------------------------------------------------
+110:  __NR_timer_settime 4s 2m
+-----------------------------------------------------
+Syscall param timer_settime(timerid) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1162)
+
+Syscall param timer_settime(flags) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1162)
+
+Syscall param timer_settime(value) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1162)
+
+Syscall param timer_settime(ovalue) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1162)
+
+Syscall param timer_settime(value) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:1162)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+Syscall param timer_settime(ovalue) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:1162)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+-----------------------------------------------------
+108:  __NR_timer_gettime 2s 1m
+-----------------------------------------------------
+Syscall param timer_gettime(timerid) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1166)
+
+Syscall param timer_gettime(value) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1166)
+
+Syscall param timer_gettime(value) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:1166)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+-----------------------------------------------------
+109:__NR_timer_getoverrun 1s 0m
+-----------------------------------------------------
+Syscall param timer_getoverrun(timerid) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1170)
+
+-----------------------------------------------------
+111:   __NR_timer_delete 1s 0m
+-----------------------------------------------------
+Syscall param timer_delete(timerid) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1174)
+
+-----------------------------------------------------
+112:  __NR_clock_settime 2s 1m
+-----------------------------------------------------
+Syscall param clock_settime(clk_id) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1178)
+
+Syscall param clock_settime(tp) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1178)
+
+Syscall param clock_settime(tp) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:1178)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+-----------------------------------------------------
+113:  __NR_clock_gettime 2s 1m
+-----------------------------------------------------
+Syscall param clock_gettime(clk_id) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1182)
+
+Syscall param clock_gettime(tp) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1182)
+
+Syscall param clock_gettime(tp) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:1182)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+-----------------------------------------------------
+114:   __NR_clock_getres 2s 1m
+-----------------------------------------------------
+Syscall param clock_getres(clk_id) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1186)
+
+Syscall param clock_getres(res) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1186)
+
+Syscall param clock_getres(res) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:1186)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+-----------------------------------------------------
+115:__NR_clock_nanosleep n/a
+-----------------------------------------------------
+-----------------------------------------------------
+131:         __NR_tgkill n/a
+-----------------------------------------------------
+-----------------------------------------------------
+235:          __NR_mbind n/a
+-----------------------------------------------------
+-----------------------------------------------------
+236:  __NR_get_mempolicy n/a
+-----------------------------------------------------
+-----------------------------------------------------
+237:  __NR_set_mempolicy n/a
+-----------------------------------------------------
+-----------------------------------------------------
+180:        __NR_mq_open 4s 3m
+-----------------------------------------------------
+Syscall param mq_open(name) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1230)
+
+Syscall param mq_open(oflag) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1230)
+
+Syscall param mq_open(mode) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1230)
+
+Syscall param mq_open(attr) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1230)
+
+Syscall param mq_open(name) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:1230)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+Syscall param mq_open(attr->mq_maxmsg) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:1230)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+Syscall param mq_open(attr->mq_msgsize) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:1230)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+-----------------------------------------------------
+181:      __NR_mq_unlink 1s 1m
+-----------------------------------------------------
+Syscall param mq_unlink(name) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1234)
+
+Syscall param mq_unlink(name) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:1234)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+-----------------------------------------------------
+182:   __NR_mq_timedsend 5s 2m
+-----------------------------------------------------
+Syscall param mq_timedsend(mqdes) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1238)
+
+Syscall param mq_timedsend(msg_ptr) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1238)
+
+Syscall param mq_timedsend(msg_len) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1238)
+
+Syscall param mq_timedsend(msg_prio) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1238)
+
+Syscall param mq_timedsend(abs_timeout) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1238)
+
+Syscall param mq_timedsend(msg_ptr) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:1238)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+Syscall param mq_timedsend(abs_timeout) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:1238)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+-----------------------------------------------------
+183:__NR_mq_timedreceive 5s 3m
+-----------------------------------------------------
+Syscall param mq_timedreceive(mqdes) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1242)
+
+Syscall param mq_timedreceive(msg_ptr) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1242)
+
+Syscall param mq_timedreceive(msg_len) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1242)
+
+Syscall param mq_timedreceive(msg_prio) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1242)
+
+Syscall param mq_timedreceive(abs_timeout) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1242)
+
+Syscall param mq_timedreceive(msg_ptr) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:1242)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+Syscall param mq_timedreceive(msg_prio) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:1242)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+Syscall param mq_timedreceive(abs_timeout) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:1242)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+-----------------------------------------------------
+184:      __NR_mq_notify 2s 1m
+-----------------------------------------------------
+Syscall param mq_notify(mqdes) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1246)
+
+Syscall param mq_notify(notification) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1246)
+
+Syscall param mq_notify(notification) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:1246)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+-----------------------------------------------------
+185:  __NR_mq_getsetattr 3s 2m
+-----------------------------------------------------
+Syscall param mq_getsetattr(mqdes) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1250)
+
+Syscall param mq_getsetattr(mqstat) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1250)
+
+Syscall param mq_getsetattr(omqstat) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1250)
+
+Syscall param mq_getsetattr(mqstat->mq_flags) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:1250)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+Syscall param mq_getsetattr(omqstat) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:1250)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+-----------------------------------------------------
+104:     __NR_kexec_load ni
+-----------------------------------------------------
+-----------------------------------------------------
+ 20:  __NR_epoll_create1 1s 0m
+-----------------------------------------------------
+Syscall param epoll_create1(flags) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1258)
+
+-----------------------------------------------------
+270:__NR_process_vm_readv 6s 2m
+-----------------------------------------------------
+Syscall param process_vm_readv(pid) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1262)
+
+Syscall param process_vm_readv(lvec) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1262)
+
+Syscall param process_vm_readv(liovcnt) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1262)
+
+Syscall param process_vm_readv(rvec) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1262)
+
+Syscall param process_vm_readv(riovcnt) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1262)
+
+Syscall param process_vm_readv(flags) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1262)
+
+Syscall param process_vm_readv(lvec) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:1262)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+Syscall param process_vm_readv(rvec) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:1262)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+-----------------------------------------------------
+271:__NR_process_vm_writev 6s 2m
+-----------------------------------------------------
+Syscall param process_vm_writev(pid) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1266)
+
+Syscall param process_vm_writev(lvec) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1266)
+
+Syscall param process_vm_writev(liovcnt) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1266)
+
+Syscall param process_vm_writev(rvec) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1266)
+
+Syscall param process_vm_writev(riovcnt) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1266)
+
+Syscall param process_vm_writev(flags) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1266)
+
+Syscall param process_vm_writev(lvec) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:1266)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+Syscall param process_vm_writev(rvec) points to unaddressable byte(s)
+   ...
+   by 0x........: main (scalar.c:1266)
+ Address 0x........ is not stack'd, malloc'd or (recently) free'd
+
+-----------------------------------------------------
+9999:                9999 1e
+-----------------------------------------------------
+WARNING: unhandled arm64-linux syscall: 9999
+You may be able to write your own handler.
+Read the file README_MISSING_SYSCALL_OR_IOCTL.
+Nevertheless we consider this a bug.  Please report
+it at http://valgrind.org/support/bug_reports.html.
+-----------------------------------------------------
+ 93:           __NR_exit 1s 0m
+-----------------------------------------------------
+Syscall param exit(status) contains uninitialised byte(s)
+   ...
+   by 0x........: main (scalar.c:1274)
+
diff --git a/memcheck/tests/arm64-linux/scalar.vgtest b/memcheck/tests/arm64-linux/scalar.vgtest
new file mode 100644
index 0000000..897d9e7
--- /dev/null
+++ b/memcheck/tests/arm64-linux/scalar.vgtest
@@ -0,0 +1,3 @@
+prog: scalar
+vgopts: -q --error-limit=no
+args: < scalar.c
-- 
2.5.0

From 4d8495affad088be6e8af0a5aa9c55ca7dfe3579 Mon Sep 17 00:00:00 2001
From: mjw <mjw@a5019735-40e9-0310-863c-91ae7b9d1cf9>
Date: Wed, 9 Mar 2016 16:18:37 +0000
Subject: [PATCH 3/3] Bug 359503 - Add missing syscalls for aarch64 (arm64)

Enable more arm64 syscalls. ioprio_set, ioprio_get, preadv, pwritev,
vmsplice, splice, tee, waitid, clock_nanosleep and perf_event_open.
Reported and patch (mostly) by Marcin Juszkiewicz.

git-svn-id: svn://svn.valgrind.org/valgrind/trunk@15826 a5019735-40e9-0310-863c-91ae7b9d1cf9
---
 NEWS                                      |  1 +
 coregrind/m_syswrap/syswrap-arm64-linux.c | 31 +++++++++++++------------------
 2 files changed, 14 insertions(+), 18 deletions(-)

diff --git a/coregrind/m_syswrap/syswrap-arm64-linux.c b/coregrind/m_syswrap/syswrap-arm64-linux.c
index 8f4efa6..0b78f20 100644
--- a/coregrind/m_syswrap/syswrap-arm64-linux.c
+++ b/coregrind/m_syswrap/syswrap-arm64-linux.c
@@ -885,7 +885,8 @@ static SyscallTableEntry syscall_main_table[] = {
    LINX_(__NR_inotify_add_watch, sys_inotify_add_watch), // 27
    LINX_(__NR_inotify_rm_watch,  sys_inotify_rm_watch),  // 28
    LINXY(__NR_ioctl,             sys_ioctl),             // 29
-
+   LINX_(__NR_ioprio_set,        sys_ioprio_set),        // 30
+   LINX_(__NR_ioprio_get,        sys_ioprio_get),        // 31
    GENX_(__NR_flock,             sys_flock),             // 32
    LINX_(__NR_mknodat,           sys_mknodat),           // 33
    LINX_(__NR_mkdirat,           sys_mkdirat),           // 34
@@ -922,12 +923,15 @@ static SyscallTableEntry syscall_main_table[] = {
    GENX_(__NR_writev,            sys_writev),            // 66
    GENXY(__NR_pread64,           sys_pread64),           // 67
    GENX_(__NR_pwrite64,          sys_pwrite64),          // 68
-
+   LINXY(__NR_preadv,            sys_preadv),            // 69
+   LINX_(__NR_pwritev,           sys_pwritev),           // 70
    LINXY(__NR_sendfile,          sys_sendfile),          // 71
    LINXY(__NR_pselect6,          sys_pselect6),          // 72
    LINXY(__NR_ppoll,             sys_ppoll),             // 73
    LINXY(__NR_signalfd4,         sys_signalfd4),         // 74
-
+   LINX_(__NR_vmsplice,          sys_vmsplice),          // 75
+   LINX_(__NR_splice,            sys_splice),            // 76
+   LINX_(__NR_tee,               sys_tee),               // 77
    LINX_(__NR_readlinkat,        sys_readlinkat),        // 78
    LINXY(__NR_newfstatat,        sys_newfstatat),        // 79
    GENXY(__NR_fstat,             sys_newfstat),          // 80
@@ -945,7 +949,7 @@ static SyscallTableEntry syscall_main_table[] = {
    LINX_(__NR_personality,       sys_personality),       // 92
    GENX_(__NR_exit,              sys_exit),              // 93
    LINX_(__NR_exit_group,        sys_exit_group),        // 94
-
+   LINXY(__NR_waitid,            sys_waitid),            // 95
    LINX_(__NR_set_tid_address,   sys_set_tid_address),   // 96
 
    LINXY(__NR_futex,             sys_futex),             // 98
@@ -965,7 +969,7 @@ static SyscallTableEntry syscall_main_table[] = {
    LINX_(__NR_clock_settime,     sys_clock_settime),     // 112
    LINXY(__NR_clock_gettime,     sys_clock_gettime),     // 113
    LINXY(__NR_clock_getres,      sys_clock_getres),      // 114
-
+   LINXY(__NR_clock_nanosleep,   sys_clock_nanosleep),   // 115
    LINXY(__NR_syslog,            sys_syslog),            // 116
 
    LINXY(__NR_sched_setparam,    sys_sched_setparam),    // 118
@@ -1081,12 +1085,14 @@ static SyscallTableEntry syscall_main_table[] = {
    LINX_(__NR_munlockall,        sys_munlockall),        // 231
    GENXY(__NR_mincore,           sys_mincore),           // 232
    GENX_(__NR_madvise,           sys_madvise),           // 233
+
    LINX_(__NR_mbind,             sys_mbind),             // 235
    LINXY(__NR_get_mempolicy,     sys_get_mempolicy),     // 236
    LINX_(__NR_set_mempolicy,     sys_set_mempolicy),     // 237
 
-   LINXY(__NR_recvmmsg,          sys_recvmmsg),          // 243
+   LINXY(__NR_perf_event_open,   sys_perf_event_open),   // 241
    LINXY(__NR_accept4,           sys_accept4),           // 242
+   LINXY(__NR_recvmmsg,          sys_recvmmsg),          // 243
 
    GENXY(__NR_wait4,             sys_wait4),             // 260
 
@@ -1095,6 +1101,7 @@ static SyscallTableEntry syscall_main_table[] = {
    LINXY(__NR_sendmmsg,          sys_sendmmsg),          // 269
    LINXY(__NR_process_vm_readv,  sys_process_vm_readv),  // 270
    LINX_(__NR_process_vm_writev, sys_process_vm_writev), // 271
+
    LINXY(__NR_getrandom,         sys_getrandom),         // 278
    LINXY(__NR_memfd_create,      sys_memfd_create),      // 279
 
@@ -1308,7 +1315,6 @@ static SyscallTableEntry syscall_main_table[] = {
 //ZZ    LINX_(__NR_set_tid_address,   sys_set_tid_address),   // 258
 //ZZ 
 //ZZ    LINXY(__NR_clock_getres,      sys_clock_getres),   // (timer_create+7)
-//ZZ    LINXY(__NR_clock_nanosleep,   sys_clock_nanosleep),// (timer_create+8) */*
 //ZZ    GENXY(__NR_statfs64,          sys_statfs64),       // 268
 //ZZ    GENXY(__NR_fstatfs64,         sys_fstatfs64),      // 269
 //ZZ 
@@ -1320,8 +1326,6 @@ static SyscallTableEntry syscall_main_table[] = {
 //ZZ    LINXY(__NR_get_mempolicy,     sys_get_mempolicy),  // 275 ?/?
 //ZZ    LINX_(__NR_set_mempolicy,     sys_set_mempolicy),  // 276 ?/?
 //ZZ 
-//ZZ    LINXY(__NR_waitid,            sys_waitid),         // 280
-//ZZ 
 //ZZ    LINX_(__NR_send,              sys_send),
 //ZZ    LINXY(__NR_recv,              sys_recv),
 //ZZ    LINXY(__NR_recvfrom,          sys_recvfrom),       // 292
@@ -1329,9 +1333,6 @@ static SyscallTableEntry syscall_main_table[] = {
 //ZZ    LINXY(__NR_semctl,            sys_semctl),         // 300
 //ZZ 
 //ZZ    LINX_(__NR_request_key,       sys_request_key),    // 287
-//ZZ //   LINX_(__NR_ioprio_set,        sys_ioprio_set),     // 289
-//ZZ 
-//ZZ //   LINX_(__NR_ioprio_get,        sys_ioprio_get),     // 290
 //ZZ    LINX_(__NR_inotify_init,    sys_inotify_init),   // 291
 //ZZ //   LINX_(__NR_migrate_pages,    sys_migrate_pages),    // 294
 //ZZ 
@@ -1347,11 +1348,8 @@ static SyscallTableEntry syscall_main_table[] = {
 //ZZ //   LINX_(__NR_unshare,       sys_unshare),          // 310
 //ZZ    LINX_(__NR_set_robust_list,    sys_set_robust_list),  // 311
 //ZZ    LINXY(__NR_get_robust_list,    sys_get_robust_list),  // 312
-//ZZ //   LINX_(__NR_splice,            sys_ni_syscall),       // 313
 //ZZ //   LINX_(__NR_sync_file_range,   sys_sync_file_range),  // 314
 //ZZ 
-//ZZ //   LINX_(__NR_tee,               sys_ni_syscall),       // 315
-//ZZ //   LINX_(__NR_vmsplice,          sys_ni_syscall),       // 316
 //ZZ    LINXY(__NR_move_pages,        sys_move_pages),       // 317
 //ZZ //   LINX_(__NR_getcpu,            sys_ni_syscall),       // 318
 //ZZ 
@@ -1374,10 +1372,7 @@ static SyscallTableEntry syscall_main_table[] = {
 //ZZ 
 //ZZ    LINXY(__NR_eventfd2,          sys_eventfd2),         // 356
 //ZZ    LINXY(__NR_epoll_create1,     sys_epoll_create1),    // 357
-//ZZ    LINXY(__NR_preadv,            sys_preadv),           // 361
-//ZZ    LINX_(__NR_pwritev,           sys_pwritev),          // 362
 //ZZ    LINXY(__NR_rt_tgsigqueueinfo, sys_rt_tgsigqueueinfo),// 363
-//ZZ    LINXY(__NR_perf_event_open,   sys_perf_event_open),  // 364
 //ZZ 
 //ZZ    LINXY(__NR_name_to_handle_at, sys_name_to_handle_at),// 370
 //ZZ    LINXY(__NR_open_by_handle_at, sys_open_by_handle_at),// 371
-- 
2.5.0

diff -rNu valgrind-3.11.0.orig/configure valgrind-3.11.0/configure
--- valgrind-3.11.0.orig/configure	2016-03-09 20:26:02.075924599 +0100
+++ valgrind-3.11.0/configure	2016-03-09 20:49:09.846378502 +0100
@@ -14095,7 +14095,7 @@
 #----------------------------------------------------------------------------
 
 # Nb: VEX/Makefile is generated from Makefile.vex.in.
-ac_config_files="$ac_config_files Makefile VEX/Makefile:Makefile.vex.in valgrind.spec valgrind.pc glibc-2.X.supp docs/Makefile tests/Makefile tests/vg_regtest perf/Makefile perf/vg_perf gdbserver_tests/Makefile gdbserver_tests/solaris/Makefile include/Makefile auxprogs/Makefile mpi/Makefile coregrind/Makefile memcheck/Makefile memcheck/tests/Makefile memcheck/tests/common/Makefile memcheck/tests/amd64/Makefile memcheck/tests/x86/Makefile memcheck/tests/linux/Makefile memcheck/tests/darwin/Makefile memcheck/tests/solaris/Makefile memcheck/tests/amd64-linux/Makefile memcheck/tests/x86-linux/Makefile memcheck/tests/amd64-solaris/Makefile memcheck/tests/x86-solaris/Makefile memcheck/tests/ppc32/Makefile memcheck/tests/ppc64/Makefile memcheck/tests/s390x/Makefile memcheck/tests/vbit-test/Makefile cachegrind/Makefile cachegrind/tests/Makefile cachegrind/tests/x86/Makefile cachegrind/cg_annotate cachegrind/cg_diff callgrind/Makefile callgrind/callgrind_annotate callgrind/callgrind_control callgrind/tests/Makefile helgrind/Makefile helgrind/tests/Makefile massif/Makefile massif/tests/Makefile massif/ms_print lackey/Makefile lackey/tests/Makefile none/Makefile none/tests/Makefile none/tests/scripts/Makefile none/tests/amd64/Makefile none/tests/ppc32/Makefile none/tests/ppc64/Makefile none/tests/x86/Makefile none/tests/arm/Makefile none/tests/arm64/Makefile none/tests/s390x/Makefile none/tests/mips32/Makefile none/tests/mips64/Makefile none/tests/tilegx/Makefile none/tests/linux/Makefile none/tests/darwin/Makefile none/tests/solaris/Makefile none/tests/amd64-linux/Makefile none/tests/x86-linux/Makefile none/tests/amd64-darwin/Makefile none/tests/x86-darwin/Makefile none/tests/amd64-solaris/Makefile none/tests/x86-solaris/Makefile exp-sgcheck/Makefile exp-sgcheck/tests/Makefile drd/Makefile drd/scripts/download-and-build-splash2 drd/tests/Makefile exp-bbv/Makefile exp-bbv/tests/Makefile exp-bbv/tests/x86/Makefile exp-bbv/tests/x86-linux/Makefile exp-bbv/tests/amd64-linux/Makefile exp-bbv/tests/ppc32-linux/Makefile exp-bbv/tests/arm-linux/Makefile exp-dhat/Makefile exp-dhat/tests/Makefile shared/Makefile solaris/Makefile"
+ac_config_files="$ac_config_files Makefile VEX/Makefile:Makefile.vex.in valgrind.spec valgrind.pc glibc-2.X.supp docs/Makefile tests/Makefile tests/vg_regtest perf/Makefile perf/vg_perf gdbserver_tests/Makefile gdbserver_tests/solaris/Makefile include/Makefile auxprogs/Makefile mpi/Makefile coregrind/Makefile memcheck/Makefile memcheck/tests/Makefile memcheck/tests/common/Makefile memcheck/tests/amd64/Makefile memcheck/tests/x86/Makefile memcheck/tests/linux/Makefile memcheck/tests/darwin/Makefile memcheck/tests/solaris/Makefile memcheck/tests/amd64-linux/Makefile memcheck/tests/arm64-linux/Makefile memcheck/tests/x86-linux/Makefile memcheck/tests/amd64-solaris/Makefile memcheck/tests/x86-solaris/Makefile memcheck/tests/ppc32/Makefile memcheck/tests/ppc64/Makefile memcheck/tests/s390x/Makefile memcheck/tests/vbit-test/Makefile cachegrind/Makefile cachegrind/tests/Makefile cachegrind/tests/x86/Makefile cachegrind/cg_annotate cachegrind/cg_diff callgrind/Makefile callgrind/callgrind_annotate callgrind/callgrind_control callgrind/tests/Makefile helgrind/Makefile helgrind/tests/Makefile massif/Makefile massif/tests/Makefile massif/ms_print lackey/Makefile lackey/tests/Makefile none/Makefile none/tests/Makefile none/tests/scripts/Makefile none/tests/amd64/Makefile none/tests/ppc32/Makefile none/tests/ppc64/Makefile none/tests/x86/Makefile none/tests/arm/Makefile none/tests/arm64/Makefile none/tests/s390x/Makefile none/tests/mips32/Makefile none/tests/mips64/Makefile none/tests/tilegx/Makefile none/tests/linux/Makefile none/tests/darwin/Makefile none/tests/solaris/Makefile none/tests/amd64-linux/Makefile none/tests/x86-linux/Makefile none/tests/amd64-darwin/Makefile none/tests/x86-darwin/Makefile none/tests/amd64-solaris/Makefile none/tests/x86-solaris/Makefile exp-sgcheck/Makefile exp-sgcheck/tests/Makefile drd/Makefile drd/scripts/download-and-build-splash2 drd/tests/Makefile exp-bbv/Makefile exp-bbv/tests/Makefile exp-bbv/tests/x86/Makefile exp-bbv/tests/x86-linux/Makefile exp-bbv/tests/amd64-linux/Makefile exp-bbv/tests/ppc32-linux/Makefile exp-bbv/tests/arm-linux/Makefile exp-dhat/Makefile exp-dhat/tests/Makefile shared/Makefile solaris/Makefile"
 
 ac_config_files="$ac_config_files coregrind/link_tool_exe_linux"
 
@@ -15379,6 +15379,7 @@
     "memcheck/tests/darwin/Makefile") CONFIG_FILES="$CONFIG_FILES memcheck/tests/darwin/Makefile" ;;
     "memcheck/tests/solaris/Makefile") CONFIG_FILES="$CONFIG_FILES memcheck/tests/solaris/Makefile" ;;
     "memcheck/tests/amd64-linux/Makefile") CONFIG_FILES="$CONFIG_FILES memcheck/tests/amd64-linux/Makefile" ;;
+    "memcheck/tests/arm64-linux/Makefile") CONFIG_FILES="$CONFIG_FILES memcheck/tests/arm64-linux/Makefile" ;;
     "memcheck/tests/x86-linux/Makefile") CONFIG_FILES="$CONFIG_FILES memcheck/tests/x86-linux/Makefile" ;;
     "memcheck/tests/amd64-solaris/Makefile") CONFIG_FILES="$CONFIG_FILES memcheck/tests/amd64-solaris/Makefile" ;;
     "memcheck/tests/x86-solaris/Makefile") CONFIG_FILES="$CONFIG_FILES memcheck/tests/x86-solaris/Makefile" ;;
diff -rNu valgrind-3.11.0.orig/memcheck/tests/arm64-linux/Makefile.in valgrind-3.11.0/memcheck/tests/arm64-linux/Makefile.in
--- valgrind-3.11.0.orig/memcheck/tests/arm64-linux/Makefile.in	1970-01-01 01:00:00.000000000 +0100
+++ valgrind-3.11.0/memcheck/tests/arm64-linux/Makefile.in	2016-03-09 20:49:07.190390855 +0100
@@ -0,0 +1,912 @@
+# Makefile.in generated by automake 1.14.1 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994-2013 Free Software Foundation, Inc.
+
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+# This file is used for tool tests, and also in perf/Makefile.am.
+
+# This file should be included (directly or indirectly) by every
+# Makefile.am that builds programs.  And also the top-level Makefile.am.
+
+#----------------------------------------------------------------------------
+# Global stuff
+#----------------------------------------------------------------------------
+
+
+VPATH = @srcdir@
+am__is_gnu_make = test -n '$(MAKEFILE_LIST)' && test -n '$(MAKELEVEL)'
+am__make_running_with_option = \
+  case $${target_option-} in \
+      ?) ;; \
+      *) echo "am__make_running_with_option: internal error: invalid" \
+              "target option '$${target_option-}' specified" >&2; \
+         exit 1;; \
+  esac; \
+  has_opt=no; \
+  sane_makeflags=$$MAKEFLAGS; \
+  if $(am__is_gnu_make); then \
+    sane_makeflags=$$MFLAGS; \
+  else \
+    case $$MAKEFLAGS in \
+      *\\[\ \	]*) \
+        bs=\\; \
+        sane_makeflags=`printf '%s\n' "$$MAKEFLAGS" \
+          | sed "s/$$bs$$bs[$$bs $$bs	]*//g"`;; \
+    esac; \
+  fi; \
+  skip_next=no; \
+  strip_trailopt () \
+  { \
+    flg=`printf '%s\n' "$$flg" | sed "s/$$1.*$$//"`; \
+  }; \
+  for flg in $$sane_makeflags; do \
+    test $$skip_next = yes && { skip_next=no; continue; }; \
+    case $$flg in \
+      *=*|--*) continue;; \
+        -*I) strip_trailopt 'I'; skip_next=yes;; \
+      -*I?*) strip_trailopt 'I';; \
+        -*O) strip_trailopt 'O'; skip_next=yes;; \
+      -*O?*) strip_trailopt 'O';; \
+        -*l) strip_trailopt 'l'; skip_next=yes;; \
+      -*l?*) strip_trailopt 'l';; \
+      -[dEDm]) skip_next=yes;; \
+      -[JT]) skip_next=yes;; \
+    esac; \
+    case $$flg in \
+      *$$target_option*) has_opt=yes; break;; \
+    esac; \
+  done; \
+  test $$has_opt = yes
+am__make_dryrun = (target_option=n; $(am__make_running_with_option))
+am__make_keepgoing = (target_option=k; $(am__make_running_with_option))
+pkgdatadir = $(datadir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkglibexecdir = $(libexecdir)/@PACKAGE@
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+DIST_COMMON = $(top_srcdir)/Makefile.tool-tests.am \
+	$(top_srcdir)/Makefile.all.am $(srcdir)/Makefile.in \
+	$(srcdir)/Makefile.am $(dist_noinst_SCRIPTS) \
+	$(top_srcdir)/depcomp $(noinst_HEADERS)
+@COMPILER_IS_CLANG_TRUE@am__append_1 = -Wno-cast-align -Wno-self-assign \
+@COMPILER_IS_CLANG_TRUE@                  -Wno-tautological-compare
+
+@SOLARIS_XPG_SYMBOLS_PRESENT_TRUE@am__append_2 = -Wl,-M,$(top_srcdir)/solaris/vgpreload-solaris.mapfile
+
+# The Android toolchain includes all kinds of stdlib helpers present in
+# bionic which is bad because we are not linking with it and the Android
+# linker will panic.
+@VGCONF_PLATVARIANT_IS_ANDROID_TRUE@am__append_3 = -nostdlib
+@VGCONF_HAVE_PLATFORM_SEC_TRUE@am__append_4 = -DVGA_SEC_@VGCONF_ARCH_SEC@=1  \
+@VGCONF_HAVE_PLATFORM_SEC_TRUE@		-DVGP_SEC_@VGCONF_ARCH_PRI@_@VGCONF_OS@=1
+
+
+# Make sure that all test programs have threaded errno.
+@VGCONF_OS_IS_SOLARIS_TRUE@am__append_5 = -D_REENTRANT
+@COMPILER_IS_CLANG_TRUE@am__append_6 = -Wno-format-extra-args \
+@COMPILER_IS_CLANG_TRUE@	-Wno-literal-range \
+@COMPILER_IS_CLANG_TRUE@	-Wno-tautological-constant-out-of-range-compare \
+@COMPILER_IS_CLANG_TRUE@	-Wno-self-assign -Wno-string-plus-int \
+@COMPILER_IS_CLANG_TRUE@	-Wno-uninitialized -Wno-unused-value # \
+@COMPILER_IS_CLANG_TRUE@	clang 3.0.0
+@COMPILER_IS_CLANG_TRUE@am__append_7 = -Wno-unused-private-field    # drd/tests/tsan_unittest.cpp
+check_PROGRAMS = scalar$(EXEEXT)
+subdir = memcheck/tests/arm64-linux
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/configure.ac
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = $(top_builddir)/config.h
+CONFIG_CLEAN_FILES =
+CONFIG_CLEAN_VPATH_FILES =
+scalar_SOURCES = scalar.c
+scalar_OBJECTS = scalar.$(OBJEXT)
+scalar_LDADD = $(LDADD)
+SCRIPTS = $(dist_noinst_SCRIPTS)
+AM_V_P = $(am__v_P_@AM_V@)
+am__v_P_ = $(am__v_P_@AM_DEFAULT_V@)
+am__v_P_0 = false
+am__v_P_1 = :
+AM_V_GEN = $(am__v_GEN_@AM_V@)
+am__v_GEN_ = $(am__v_GEN_@AM_DEFAULT_V@)
+am__v_GEN_0 = @echo "  GEN     " $@;
+am__v_GEN_1 = 
+AM_V_at = $(am__v_at_@AM_V@)
+am__v_at_ = $(am__v_at_@AM_DEFAULT_V@)
+am__v_at_0 = @
+am__v_at_1 = 
+DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
+depcomp = $(SHELL) $(top_srcdir)/depcomp
+am__depfiles_maybe = depfiles
+am__mv = mv -f
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+AM_V_CC = $(am__v_CC_@AM_V@)
+am__v_CC_ = $(am__v_CC_@AM_DEFAULT_V@)
+am__v_CC_0 = @echo "  CC      " $@;
+am__v_CC_1 = 
+CCLD = $(CC)
+LINK = $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
+AM_V_CCLD = $(am__v_CCLD_@AM_V@)
+am__v_CCLD_ = $(am__v_CCLD_@AM_DEFAULT_V@)
+am__v_CCLD_0 = @echo "  CCLD    " $@;
+am__v_CCLD_1 = 
+SOURCES = scalar.c
+DIST_SOURCES = scalar.c
+am__can_run_installinfo = \
+  case $$AM_UPDATE_INFO_DIR in \
+    n|no|NO) false;; \
+    *) (install-info --version) >/dev/null 2>&1;; \
+  esac
+HEADERS = $(noinst_HEADERS)
+am__tagged_files = $(HEADERS) $(SOURCES) $(TAGS_FILES) $(LISP)
+# Read a list of newline-separated strings from the standard input,
+# and print each of them once, without duplicates.  Input order is
+# *not* preserved.
+am__uniquify_input = $(AWK) '\
+  BEGIN { nonempty = 0; } \
+  { items[$$0] = 1; nonempty = 1; } \
+  END { if (nonempty) { for (i in items) print i; }; } \
+'
+# Make sure the list of sources is unique.  This is necessary because,
+# e.g., the same source file might be shared among _SOURCES variables
+# for different programs/libraries.
+am__define_uniq_tagged_files = \
+  list='$(am__tagged_files)'; \
+  unique=`for i in $$list; do \
+    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+  done | $(am__uniquify_input)`
+ETAGS = etags
+CTAGS = ctags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMTAR = @AMTAR@
+AM_DEFAULT_VERBOSITY = @AM_DEFAULT_VERBOSITY@
+AR = @AR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+BOOST_CFLAGS = @BOOST_CFLAGS@
+BOOST_LIBS = @BOOST_LIBS@
+CC = @CC@
+CCAS = @CCAS@
+CCASDEPMODE = @CCASDEPMODE@
+CCASFLAGS = @CCASFLAGS@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CFLAGS_MPI = @CFLAGS_MPI@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CXX = @CXX@
+CXXDEPMODE = @CXXDEPMODE@
+CXXFLAGS = @CXXFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFAULT_SUPP = @DEFAULT_SUPP@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DIFF = @DIFF@
+DIS_PATH = @DIS_PATH@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+FLAG_FNO_IPA_ICF = @FLAG_FNO_IPA_ICF@
+FLAG_FNO_STACK_PROTECTOR = @FLAG_FNO_STACK_PROTECTOR@
+FLAG_FSANITIZE = @FLAG_FSANITIZE@
+FLAG_M32 = @FLAG_M32@
+FLAG_M64 = @FLAG_M64@
+FLAG_MIPS32 = @FLAG_MIPS32@
+FLAG_MIPS64 = @FLAG_MIPS64@
+FLAG_MLONG_DOUBLE_128 = @FLAG_MLONG_DOUBLE_128@
+FLAG_MMMX = @FLAG_MMMX@
+FLAG_MSSE = @FLAG_MSSE@
+FLAG_NO_BUILD_ID = @FLAG_NO_BUILD_ID@
+FLAG_OCTEON = @FLAG_OCTEON@
+FLAG_OCTEON2 = @FLAG_OCTEON2@
+FLAG_T_TEXT = @FLAG_T_TEXT@
+FLAG_UNLIMITED_INLINE_UNIT_GROWTH = @FLAG_UNLIMITED_INLINE_UNIT_GROWTH@
+FLAG_W_CAST_ALIGN = @FLAG_W_CAST_ALIGN@
+FLAG_W_CAST_QUAL = @FLAG_W_CAST_QUAL@
+FLAG_W_EMPTY_BODY = @FLAG_W_EMPTY_BODY@
+FLAG_W_EXTRA = @FLAG_W_EXTRA@
+FLAG_W_FORMAT = @FLAG_W_FORMAT@
+FLAG_W_FORMAT_SECURITY = @FLAG_W_FORMAT_SECURITY@
+FLAG_W_FORMAT_SIGNEDNESS = @FLAG_W_FORMAT_SIGNEDNESS@
+FLAG_W_IGNORED_QUALIFIERS = @FLAG_W_IGNORED_QUALIFIERS@
+FLAG_W_MISSING_PARAMETER_TYPE = @FLAG_W_MISSING_PARAMETER_TYPE@
+FLAG_W_NO_INFINITE_RECURSION = @FLAG_W_NO_INFINITE_RECURSION@
+FLAG_W_NO_MEMSET_TRANSPOSED_ARGS = @FLAG_W_NO_MEMSET_TRANSPOSED_ARGS@
+FLAG_W_NO_MISMATCHED_NEW_DELETE = @FLAG_W_NO_MISMATCHED_NEW_DELETE@
+FLAG_W_NO_NONNULL = @FLAG_W_NO_NONNULL@
+FLAG_W_NO_OVERFLOW = @FLAG_W_NO_OVERFLOW@
+FLAG_W_NO_POINTER_SIGN = @FLAG_W_NO_POINTER_SIGN@
+FLAG_W_NO_STATIC_LOCAL_IN_INLINE = @FLAG_W_NO_STATIC_LOCAL_IN_INLINE@
+FLAG_W_NO_UNINITIALIZED = @FLAG_W_NO_UNINITIALIZED@
+FLAG_W_NO_UNUSED_FUNCTION = @FLAG_W_NO_UNUSED_FUNCTION@
+FLAG_W_OLD_STYLE_DECLARATION = @FLAG_W_OLD_STYLE_DECLARATION@
+FLAG_W_WRITE_STRINGS = @FLAG_W_WRITE_STRINGS@
+GDB = @GDB@
+GLIBC_VERSION = @GLIBC_VERSION@
+GREP = @GREP@
+HWCAP_HAS_ALTIVEC = @HWCAP_HAS_ALTIVEC@
+HWCAP_HAS_DFP = @HWCAP_HAS_DFP@
+HWCAP_HAS_HTM = @HWCAP_HAS_HTM@
+HWCAP_HAS_ISA_2_05 = @HWCAP_HAS_ISA_2_05@
+HWCAP_HAS_ISA_2_06 = @HWCAP_HAS_ISA_2_06@
+HWCAP_HAS_ISA_2_07 = @HWCAP_HAS_ISA_2_07@
+HWCAP_HAS_VSX = @HWCAP_HAS_VSX@
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LDFLAGS = @LDFLAGS@
+LDFLAGS_MPI = @LDFLAGS_MPI@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIB_UBSAN = @LIB_UBSAN@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+MAINT = @MAINT@
+MAKEINFO = @MAKEINFO@
+MKDIR_P = @MKDIR_P@
+MPI_CC = @MPI_CC@
+OBJEXT = @OBJEXT@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_URL = @PACKAGE_URL@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+PERL = @PERL@
+PREFERRED_STACK_BOUNDARY_2 = @PREFERRED_STACK_BOUNDARY_2@
+RANLIB = @RANLIB@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STRIP = @STRIP@
+VALT_LOAD_ADDRESS_PRI = @VALT_LOAD_ADDRESS_PRI@
+VALT_LOAD_ADDRESS_SEC = @VALT_LOAD_ADDRESS_SEC@
+VERSION = @VERSION@
+VGCONF_ARCH_PRI = @VGCONF_ARCH_PRI@
+VGCONF_ARCH_SEC = @VGCONF_ARCH_SEC@
+VGCONF_OS = @VGCONF_OS@
+VGCONF_PLATFORM_PRI_CAPS = @VGCONF_PLATFORM_PRI_CAPS@
+VGCONF_PLATFORM_SEC_CAPS = @VGCONF_PLATFORM_SEC_CAPS@
+VGCONF_PLATVARIANT = @VGCONF_PLATVARIANT@
+VG_TMPDIR = @VG_TMPDIR@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_CXX = @ac_ct_CXX@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+builddir = @builddir@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dvidir = @dvidir@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+top_build_prefix = @top_build_prefix@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+inplacedir = $(top_builddir)/.in_place
+
+#----------------------------------------------------------------------------
+# Flags
+#----------------------------------------------------------------------------
+
+# Baseline flags for all compilations.  Aim here is to maximise
+# performance and get whatever useful warnings we can out of gcc.
+# -fno-builtin is important for defeating LLVM's idiom recognition
+# that somehow causes VG_(memset) to get into infinite recursion.
+AM_CFLAGS_BASE = -O2 -g -std=gnu99 -Wall -Wmissing-prototypes -Wshadow \
+	-Wpointer-arith -Wstrict-prototypes -Wmissing-declarations \
+	@FLAG_W_CAST_ALIGN@ @FLAG_W_CAST_QUAL@ @FLAG_W_WRITE_STRINGS@ \
+	@FLAG_W_EMPTY_BODY@ @FLAG_W_FORMAT@ @FLAG_W_FORMAT_SIGNEDNESS@ \
+	@FLAG_W_FORMAT_SECURITY@ @FLAG_W_IGNORED_QUALIFIERS@ \
+	@FLAG_W_MISSING_PARAMETER_TYPE@ @FLAG_W_OLD_STYLE_DECLARATION@ \
+	@FLAG_FNO_STACK_PROTECTOR@ @FLAG_FSANITIZE@ \
+	-fno-strict-aliasing -fno-builtin $(am__append_1)
+@VGCONF_OS_IS_DARWIN_FALSE@AM_CFLAGS_PSO_BASE = -O -g -fno-omit-frame-pointer -fno-strict-aliasing \
+@VGCONF_OS_IS_DARWIN_FALSE@		     -fpic -fno-builtin @FLAG_FNO_IPA_ICF@
+
+
+# These flags are used for building the preload shared objects (PSOs).
+# The aim is to give reasonable performance but also to have good
+# stack traces, since users often see stack traces extending 
+# into (and through) the preloads.  Also, we must use any
+# -mpreferred-stack-boundary flag to build the preload shared
+# objects, since that risks misaligning the client's stack and
+# results in segfaults like (eg) #324050.
+@VGCONF_OS_IS_DARWIN_TRUE@AM_CFLAGS_PSO_BASE = -dynamic \
+@VGCONF_OS_IS_DARWIN_TRUE@		     -O -g -fno-omit-frame-pointer -fno-strict-aliasing \
+@VGCONF_OS_IS_DARWIN_TRUE@		     -fpic -fPIC -fno-builtin @FLAG_FNO_IPA_ICF@
+
+
+# Flags for specific targets.
+#
+# Nb: the AM_CPPFLAGS_* values are suitable for building tools and auxprogs.
+# For building the core, coregrind/Makefile.am files add some extra things.
+AM_CPPFLAGS_@VGCONF_PLATFORM_PRI_CAPS@ = \
+	-I$(top_srcdir) \
+	-I$(top_srcdir)/include \
+	-I$(top_srcdir)/VEX/pub \
+	-I$(top_builddir)/VEX/pub \
+	-DVGA_@VGCONF_ARCH_PRI@=1 \
+	-DVGO_@VGCONF_OS@=1 \
+	-DVGP_@VGCONF_ARCH_PRI@_@VGCONF_OS@=1 \
+	-DVGPV_@VGCONF_ARCH_PRI@_@VGCONF_OS@_@VGCONF_PLATVARIANT@=1
+
+@VGCONF_HAVE_PLATFORM_SEC_TRUE@AM_CPPFLAGS_@VGCONF_PLATFORM_SEC_CAPS@ = \
+@VGCONF_HAVE_PLATFORM_SEC_TRUE@	-I$(top_srcdir) \
+@VGCONF_HAVE_PLATFORM_SEC_TRUE@	-I$(top_srcdir)/include \
+@VGCONF_HAVE_PLATFORM_SEC_TRUE@	-I$(top_srcdir)/VEX/pub \
+@VGCONF_HAVE_PLATFORM_SEC_TRUE@	-I$(top_builddir)/VEX/pub \
+@VGCONF_HAVE_PLATFORM_SEC_TRUE@	-DVGA_@VGCONF_ARCH_SEC@=1 \
+@VGCONF_HAVE_PLATFORM_SEC_TRUE@	-DVGO_@VGCONF_OS@=1 \
+@VGCONF_HAVE_PLATFORM_SEC_TRUE@	-DVGP_@VGCONF_ARCH_SEC@_@VGCONF_OS@=1 \
+@VGCONF_HAVE_PLATFORM_SEC_TRUE@	-DVGPV_@VGCONF_ARCH_SEC@_@VGCONF_OS@_@VGCONF_PLATVARIANT@=1
+
+AM_FLAG_M3264_X86_LINUX = @FLAG_M32@
+AM_CFLAGS_X86_LINUX = @FLAG_M32@ @PREFERRED_STACK_BOUNDARY_2@ \
+				$(AM_CFLAGS_BASE) -fomit-frame-pointer
+
+AM_CFLAGS_PSO_X86_LINUX = @FLAG_M32@ $(AM_CFLAGS_BASE) $(AM_CFLAGS_PSO_BASE)
+AM_CCASFLAGS_X86_LINUX = @FLAG_M32@ -g
+AM_FLAG_M3264_AMD64_LINUX = @FLAG_M64@
+AM_CFLAGS_AMD64_LINUX = @FLAG_M64@ \
+				$(AM_CFLAGS_BASE) -fomit-frame-pointer
+
+AM_CFLAGS_PSO_AMD64_LINUX = @FLAG_M64@ $(AM_CFLAGS_BASE) $(AM_CFLAGS_PSO_BASE)
+AM_CCASFLAGS_AMD64_LINUX = @FLAG_M64@ -g
+AM_FLAG_M3264_PPC32_LINUX = @FLAG_M32@
+AM_CFLAGS_PPC32_LINUX = @FLAG_M32@ $(AM_CFLAGS_BASE)
+AM_CFLAGS_PSO_PPC32_LINUX = @FLAG_M32@ $(AM_CFLAGS_BASE) $(AM_CFLAGS_PSO_BASE)
+AM_CCASFLAGS_PPC32_LINUX = @FLAG_M32@ -g
+AM_FLAG_M3264_PPC64BE_LINUX = @FLAG_M64@
+AM_CFLAGS_PPC64BE_LINUX = @FLAG_M64@ $(AM_CFLAGS_BASE)
+AM_CFLAGS_PSO_PPC64BE_LINUX = @FLAG_M64@ $(AM_CFLAGS_BASE) $(AM_CFLAGS_PSO_BASE)
+AM_CCASFLAGS_PPC64BE_LINUX = @FLAG_M64@ -g
+AM_FLAG_M3264_PPC64LE_LINUX = @FLAG_M64@
+AM_CFLAGS_PPC64LE_LINUX = @FLAG_M64@ $(AM_CFLAGS_BASE)
+AM_CFLAGS_PSO_PPC64LE_LINUX = @FLAG_M64@ $(AM_CFLAGS_BASE) $(AM_CFLAGS_PSO_BASE)
+AM_CCASFLAGS_PPC64LE_LINUX = @FLAG_M64@ -g
+AM_FLAG_M3264_ARM_LINUX = @FLAG_M32@
+AM_CFLAGS_ARM_LINUX = @FLAG_M32@ \
+			 	$(AM_CFLAGS_BASE) -marm -mcpu=cortex-a8
+
+AM_CFLAGS_PSO_ARM_LINUX = @FLAG_M32@ $(AM_CFLAGS_BASE) \
+				-marm -mcpu=cortex-a8 $(AM_CFLAGS_PSO_BASE)
+
+AM_CCASFLAGS_ARM_LINUX = @FLAG_M32@ \
+				-marm -mcpu=cortex-a8 -g
+
+AM_FLAG_M3264_ARM64_LINUX = @FLAG_M64@
+AM_CFLAGS_ARM64_LINUX = @FLAG_M64@ $(AM_CFLAGS_BASE)
+AM_CFLAGS_PSO_ARM64_LINUX = @FLAG_M64@ $(AM_CFLAGS_BASE) $(AM_CFLAGS_PSO_BASE)
+AM_CCASFLAGS_ARM64_LINUX = @FLAG_M64@ -g
+AM_FLAG_M3264_X86_DARWIN = -arch i386
+AM_CFLAGS_X86_DARWIN = $(WERROR) -arch i386 $(AM_CFLAGS_BASE) \
+				-mmacosx-version-min=10.5 \
+				-fno-stack-protector -fno-pic -fno-PIC
+
+AM_CFLAGS_PSO_X86_DARWIN = $(AM_CFLAGS_X86_DARWIN) $(AM_CFLAGS_PSO_BASE)
+AM_CCASFLAGS_X86_DARWIN = -arch i386 -g
+AM_FLAG_M3264_AMD64_DARWIN = -arch x86_64
+AM_CFLAGS_AMD64_DARWIN = $(WERROR) -arch x86_64 $(AM_CFLAGS_BASE) \
+			    -mmacosx-version-min=10.5 -fno-stack-protector
+
+AM_CFLAGS_PSO_AMD64_DARWIN = $(AM_CFLAGS_AMD64_DARWIN) $(AM_CFLAGS_PSO_BASE)
+AM_CCASFLAGS_AMD64_DARWIN = -arch x86_64 -g
+AM_FLAG_M3264_S390X_LINUX = @FLAG_M64@
+AM_CFLAGS_S390X_LINUX = @FLAG_M64@ $(AM_CFLAGS_BASE) -fomit-frame-pointer
+AM_CFLAGS_PSO_S390X_LINUX = @FLAG_M64@ $(AM_CFLAGS_BASE) $(AM_CFLAGS_PSO_BASE)
+AM_CCASFLAGS_S390X_LINUX = @FLAG_M64@ -g -mzarch -march=z900
+AM_FLAG_M3264_MIPS32_LINUX = @FLAG_M32@
+AM_CFLAGS_MIPS32_LINUX = @FLAG_M32@ $(AM_CFLAGS_BASE) @FLAG_MIPS32@
+AM_CFLAGS_PSO_MIPS32_LINUX = @FLAG_M32@ $(AM_CFLAGS_BASE) @FLAG_MIPS32@ \
+				$(AM_CFLAGS_PSO_BASE)
+
+AM_CCASFLAGS_MIPS32_LINUX = @FLAG_M32@ -g @FLAG_MIPS32@
+AM_FLAG_M3264_MIPS64_LINUX = @FLAG_M64@
+AM_CFLAGS_MIPS64_LINUX = @FLAG_M64@ $(AM_CFLAGS_BASE) @FLAG_MIPS64@
+AM_CFLAGS_PSO_MIPS64_LINUX = @FLAG_M64@ $(AM_CFLAGS_BASE) @FLAG_MIPS64@ \
+				$(AM_CFLAGS_PSO_BASE)
+
+AM_CCASFLAGS_MIPS64_LINUX = @FLAG_M64@ -g @FLAG_MIPS64@
+AM_CFLAGS_TILEGX_LINUX = @FLAG_M64@ $(AM_CFLAGS_BASE)
+AM_CFLAGS_PSO_TILEGX_LINUX = @FLAG_M64@ $(AM_CFLAGS_BASE) $(AM_CFLAGS_PSO_BASE)
+AM_FLAG_M3264_X86_SOLARIS = @FLAG_M32@
+AM_CFLAGS_X86_SOLARIS = @FLAG_M32@ @PREFERRED_STACK_BOUNDARY_2@ \
+			 	$(AM_CFLAGS_BASE) -fomit-frame-pointer
+
+AM_CFLAGS_PSO_X86_SOLARIS = @FLAG_M32@ $(AM_CFLAGS_BASE) $(AM_CFLAGS_PSO_BASE)
+AM_CCASFLAGS_X86_SOLARIS = @FLAG_M32@ -g -D_ASM
+AM_FLAG_M3264_AMD64_SOLARIS = @FLAG_M64@
+AM_CFLAGS_AMD64_SOLARIS = @FLAG_M64@ \
+				$(AM_CFLAGS_BASE) -fomit-frame-pointer
+
+AM_CFLAGS_PSO_AMD64_SOLARIS = @FLAG_M64@ $(AM_CFLAGS_BASE) $(AM_CFLAGS_PSO_BASE)
+AM_CCASFLAGS_AMD64_SOLARIS = @FLAG_M64@ -g -D_ASM
+
+# Flags for the primary target.  These must be used to build the
+# regtests and performance tests.  In fact, these must be used to
+# build anything which is built only once on a dual-arch build.
+#
+AM_FLAG_M3264_PRI = $(AM_FLAG_M3264_@VGCONF_PLATFORM_PRI_CAPS@)
+AM_CPPFLAGS_PRI = $(AM_CPPFLAGS_@VGCONF_PLATFORM_PRI_CAPS@)
+AM_CFLAGS_PRI = $(AM_CFLAGS_@VGCONF_PLATFORM_PRI_CAPS@)
+AM_CCASFLAGS_PRI = $(AM_CCASFLAGS_@VGCONF_PLATFORM_PRI_CAPS@)
+@VGCONF_HAVE_PLATFORM_SEC_FALSE@AM_FLAG_M3264_SEC = 
+@VGCONF_HAVE_PLATFORM_SEC_TRUE@AM_FLAG_M3264_SEC = $(AM_FLAG_M3264_@VGCONF_PLATFORM_SEC_CAPS@)
+
+# Baseline link flags for making vgpreload shared objects.
+#
+PRELOAD_LDFLAGS_COMMON_LINUX = -nodefaultlibs -shared \
+	-Wl,-z,interpose,-z,initfirst $(am__append_3)
+PRELOAD_LDFLAGS_COMMON_DARWIN = -dynamic -dynamiclib -all_load
+PRELOAD_LDFLAGS_COMMON_SOLARIS = -nodefaultlibs -shared \
+	-Wl,-z,interpose,-z,initfirst $(am__append_2)
+PRELOAD_LDFLAGS_X86_LINUX = $(PRELOAD_LDFLAGS_COMMON_LINUX) @FLAG_M32@
+PRELOAD_LDFLAGS_AMD64_LINUX = $(PRELOAD_LDFLAGS_COMMON_LINUX) @FLAG_M64@
+PRELOAD_LDFLAGS_PPC32_LINUX = $(PRELOAD_LDFLAGS_COMMON_LINUX) @FLAG_M32@
+PRELOAD_LDFLAGS_PPC64BE_LINUX = $(PRELOAD_LDFLAGS_COMMON_LINUX) @FLAG_M64@
+PRELOAD_LDFLAGS_PPC64LE_LINUX = $(PRELOAD_LDFLAGS_COMMON_LINUX) @FLAG_M64@
+PRELOAD_LDFLAGS_ARM_LINUX = $(PRELOAD_LDFLAGS_COMMON_LINUX) @FLAG_M32@
+PRELOAD_LDFLAGS_ARM64_LINUX = $(PRELOAD_LDFLAGS_COMMON_LINUX) @FLAG_M64@
+PRELOAD_LDFLAGS_X86_DARWIN = $(PRELOAD_LDFLAGS_COMMON_DARWIN) -arch i386
+PRELOAD_LDFLAGS_AMD64_DARWIN = $(PRELOAD_LDFLAGS_COMMON_DARWIN) -arch x86_64
+PRELOAD_LDFLAGS_S390X_LINUX = $(PRELOAD_LDFLAGS_COMMON_LINUX) @FLAG_M64@
+PRELOAD_LDFLAGS_MIPS32_LINUX = $(PRELOAD_LDFLAGS_COMMON_LINUX) @FLAG_M32@
+PRELOAD_LDFLAGS_MIPS64_LINUX = $(PRELOAD_LDFLAGS_COMMON_LINUX) @FLAG_M64@
+PRELOAD_LDFLAGS_TILEGX_LINUX = $(PRELOAD_LDFLAGS_COMMON_LINUX) @FLAG_M64@
+PRELOAD_LDFLAGS_X86_SOLARIS = $(PRELOAD_LDFLAGS_COMMON_SOLARIS) @FLAG_M32@
+PRELOAD_LDFLAGS_AMD64_SOLARIS = $(PRELOAD_LDFLAGS_COMMON_SOLARIS) @FLAG_M64@
+AM_CPPFLAGS = -I$(top_srcdir) -I$(top_srcdir)/include \
+	-I$(top_srcdir)/coregrind -I$(top_builddir)/include \
+	-I$(top_srcdir)/VEX/pub -I$(top_builddir)/VEX/pub \
+	-DVGA_@VGCONF_ARCH_PRI@=1 -DVGO_@VGCONF_OS@=1 \
+	-DVGP_@VGCONF_ARCH_PRI@_@VGCONF_OS@=1 \
+	-DVGPV_@VGCONF_ARCH_PRI@_@VGCONF_OS@_@VGCONF_PLATVARIANT@=1 \
+	$(am__append_4)
+
+# Nb: Tools need to augment these flags with an arch-selection option, such
+# as $(AM_FLAG_M3264_PRI).
+AM_CFLAGS = -Winline -Wall -Wshadow -Wno-long-long -g \
+	@FLAG_FNO_STACK_PROTECTOR@ $(am__append_5) $(am__append_6) \
+	@FLAG_M64@ $(am__empty)
+AM_CXXFLAGS = -Winline -Wall -Wshadow -Wno-long-long -g \
+	@FLAG_FNO_STACK_PROTECTOR@ $(am__append_7) @FLAG_M64@
+# Include AM_CPPFLAGS in AM_CCASFLAGS to allow for older versions of
+# automake;  see comments in Makefile.all.am for more detail.
+AM_CCASFLAGS = $(AM_CPPFLAGS) @FLAG_M64@
+@VGCONF_OS_IS_DARWIN_TRUE@noinst_DSYMS = $(check_PROGRAMS)
+dist_noinst_SCRIPTS = \
+	filter_stderr
+
+noinst_HEADERS = scalar.h
+EXTRA_DIST = \
+	scalar.stderr.exp scalar.vgtest
+
+all: all-am
+
+.SUFFIXES:
+.SUFFIXES: .c .o .obj
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am $(top_srcdir)/Makefile.tool-tests.am $(top_srcdir)/Makefile.all.am $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
+	        && { if test -f $@; then exit 0; else break; fi; }; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign memcheck/tests/arm64-linux/Makefile'; \
+	$(am__cd) $(top_srcdir) && \
+	  $(AUTOMAKE) --foreign memcheck/tests/arm64-linux/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+$(top_srcdir)/Makefile.tool-tests.am $(top_srcdir)/Makefile.all.am:
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(am__aclocal_m4_deps):
+
+clean-checkPROGRAMS:
+	-test -z "$(check_PROGRAMS)" || rm -f $(check_PROGRAMS)
+
+scalar$(EXEEXT): $(scalar_OBJECTS) $(scalar_DEPENDENCIES) $(EXTRA_scalar_DEPENDENCIES) 
+	@rm -f scalar$(EXEEXT)
+	$(AM_V_CCLD)$(LINK) $(scalar_OBJECTS) $(scalar_LDADD) $(LIBS)
+
+mostlyclean-compile:
+	-rm -f *.$(OBJEXT)
+
+distclean-compile:
+	-rm -f *.tab.c
+
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/scalar.Po@am__quote@
+
+.c.o:
+@am__fastdepCC_TRUE@	$(AM_V_CC)depbase=`echo $@ | sed 's|[^/]*$$|$(DEPDIR)/&|;s|\.o$$||'`;\
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $$depbase.Tpo -c -o $@ $< &&\
+@am__fastdepCC_TRUE@	$(am__mv) $$depbase.Tpo $$depbase.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(COMPILE) -c -o $@ $<
+
+.c.obj:
+@am__fastdepCC_TRUE@	$(AM_V_CC)depbase=`echo $@ | sed 's|[^/]*$$|$(DEPDIR)/&|;s|\.obj$$||'`;\
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $$depbase.Tpo -c -o $@ `$(CYGPATH_W) '$<'` &&\
+@am__fastdepCC_TRUE@	$(am__mv) $$depbase.Tpo $$depbase.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(COMPILE) -c -o $@ `$(CYGPATH_W) '$<'`
+
+ID: $(am__tagged_files)
+	$(am__define_uniq_tagged_files); mkid -fID $$unique
+tags: tags-am
+TAGS: tags
+
+tags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
+	set x; \
+	here=`pwd`; \
+	$(am__define_uniq_tagged_files); \
+	shift; \
+	if test -z "$(ETAGS_ARGS)$$*$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  if test $$# -gt 0; then \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      "$$@" $$unique; \
+	  else \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      $$unique; \
+	  fi; \
+	fi
+ctags: ctags-am
+
+CTAGS: ctags
+ctags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
+	$(am__define_uniq_tagged_files); \
+	test -z "$(CTAGS_ARGS)$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && $(am__cd) $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) "$$here"
+cscopelist: cscopelist-am
+
+cscopelist-am: $(am__tagged_files)
+	list='$(am__tagged_files)'; \
+	case "$(srcdir)" in \
+	  [\\/]* | ?:[\\/]*) sdir="$(srcdir)" ;; \
+	  *) sdir=$(subdir)/$(srcdir) ;; \
+	esac; \
+	for i in $$list; do \
+	  if test -f "$$i"; then \
+	    echo "$(subdir)/$$i"; \
+	  else \
+	    echo "$$sdir/$$i"; \
+	  fi; \
+	done >> $(top_builddir)/cscope.files
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d "$(distdir)/$$file"; then \
+	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
+	    fi; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -fpR $(srcdir)/$$file "$(distdir)$$dir" || exit 1; \
+	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
+	    fi; \
+	    cp -fpR $$d/$$file "$(distdir)$$dir" || exit 1; \
+	  else \
+	    test -f "$(distdir)/$$file" \
+	    || cp -p $$d/$$file "$(distdir)/$$file" \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+	$(MAKE) $(AM_MAKEFLAGS) $(check_PROGRAMS)
+	$(MAKE) $(AM_MAKEFLAGS) check-local
+check: check-am
+all-am: Makefile $(SCRIPTS) $(HEADERS)
+installdirs:
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	if test -z '$(STRIP)'; then \
+	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	      install; \
+	else \
+	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	    "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'" install; \
+	fi
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+	-test . = "$(srcdir)" || test -z "$(CONFIG_CLEAN_VPATH_FILES)" || rm -f $(CONFIG_CLEAN_VPATH_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-checkPROGRAMS clean-generic clean-local mostlyclean-am
+
+distclean: distclean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+html-am:
+
+info: info-am
+
+info-am:
+
+install-data-am:
+
+install-dvi: install-dvi-am
+
+install-dvi-am:
+
+install-exec-am:
+
+install-html: install-html-am
+
+install-html-am:
+
+install-info: install-info-am
+
+install-info-am:
+
+install-man:
+
+install-pdf: install-pdf-am
+
+install-pdf-am:
+
+install-ps: install-ps-am
+
+install-ps-am:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-compile mostlyclean-generic
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am:
+
+.MAKE: check-am install-am install-strip
+
+.PHONY: CTAGS GTAGS TAGS all all-am check check-am check-local clean \
+	clean-checkPROGRAMS clean-generic clean-local cscopelist-am \
+	ctags ctags-am distclean distclean-compile distclean-generic \
+	distclean-tags distdir dvi dvi-am html html-am info info-am \
+	install install-am install-data install-data-am install-dvi \
+	install-dvi-am install-exec install-exec-am install-html \
+	install-html-am install-info install-info-am install-man \
+	install-pdf install-pdf-am install-ps install-ps-am \
+	install-strip installcheck installcheck-am installdirs \
+	maintainer-clean maintainer-clean-generic mostlyclean \
+	mostlyclean-compile mostlyclean-generic pdf pdf-am ps ps-am \
+	tags tags-am uninstall uninstall-am
+
+
+# This used to be required when Vex had a handwritten Makefile.  It
+# shouldn't be needed any more, though.
+
+#----------------------------------------------------------------------------
+# noinst_PROGRAMS and noinst_DSYMS targets
+#----------------------------------------------------------------------------
+
+# On Darwin, for a program 'p', the DWARF debug info is stored in the
+# directory 'p.dSYM'.  This must be generated after the executable is
+# created, with 'dsymutil p'.  We could redefine LINK with a script that
+# executes 'dsymutil' after linking, but that's a pain.  Instead we use this
+# hook so that every time "make check" is run, we subsequently invoke
+# 'dsymutil' on all the executables that lack a .dSYM directory, or that are
+# newer than their corresponding .dSYM directory.
+build-noinst_DSYMS: $(noinst_DSYMS)
+	for f in $(noinst_DSYMS); do \
+	  if [ ! -e $$f.dSYM  -o  $$f -nt $$f.dSYM ] ; then \
+	      echo "dsymutil $$f"; \
+	      dsymutil $$f; \
+	  fi; \
+	done
+
+# This is used by coregrind/Makefile.am and Makefile.tool.am for doing
+# "in-place" installs.  It copies $(noinst_PROGRAMS) into $inplacedir.
+# It needs to be depended on by an 'all-local' rule.
+inplace-noinst_PROGRAMS: $(noinst_PROGRAMS)
+	mkdir -p $(inplacedir); \
+	for f in $(noinst_PROGRAMS) ; do \
+	  rm -f $(inplacedir)/$$f; \
+	  ln -f -s ../$(subdir)/$$f $(inplacedir); \
+	done
+
+# Similar to inplace-noinst_PROGRAMS
+inplace-noinst_DSYMS: build-noinst_DSYMS
+	mkdir -p $(inplacedir); \
+	for f in $(noinst_DSYMS); do \
+	  rm -f $(inplacedir)/$$f.dSYM; \
+	  ln -f -s ../$(subdir)/$$f.dSYM $(inplacedir); \
+	done
+
+# This is used by coregrind/Makefile.am and by <tool>/Makefile.am for doing
+# "make install".  It copies $(noinst_PROGRAMS) into $prefix/lib/valgrind/.
+# It needs to be depended on by an 'install-exec-local' rule.
+install-noinst_PROGRAMS: $(noinst_PROGRAMS)
+	$(mkinstalldirs) $(DESTDIR)$(pkglibdir); \
+	for f in $(noinst_PROGRAMS); do \
+	  $(INSTALL_PROGRAM) $$f $(DESTDIR)$(pkglibdir); \
+	done
+
+# This is used by coregrind/Makefile.am and by <tool>/Makefile.am for doing
+# "make uninstall".  It removes $(noinst_PROGRAMS) from $prefix/lib/valgrind/.
+# It needs to be depended on by an 'uninstall-local' rule.
+uninstall-noinst_PROGRAMS:
+	for f in $(noinst_PROGRAMS); do \
+	  rm -f $(DESTDIR)$(pkglibdir)/$$f; \
+	done
+
+# Similar to install-noinst_PROGRAMS.
+# Nb: we don't use $(INSTALL_PROGRAM) here because it doesn't work with
+# directories.  XXX: not sure whether the resulting permissions will be
+# correct when using 'cp -R'...
+install-noinst_DSYMS: build-noinst_DSYMS
+	$(mkinstalldirs) $(DESTDIR)$(pkglibdir); \
+	for f in $(noinst_DSYMS); do \
+	  cp -R $$f.dSYM $(DESTDIR)$(pkglibdir); \
+	done
+
+# Similar to uninstall-noinst_PROGRAMS.
+uninstall-noinst_DSYMS:
+	for f in $(noinst_DSYMS); do \
+	  rm -f $(DESTDIR)$(pkglibdir)/$$f.dSYM; \
+	done
+
+# This needs to be depended on by a 'clean-local' rule.
+clean-noinst_DSYMS:
+	for f in $(noinst_DSYMS); do \
+	  rm -rf $$f.dSYM; \
+	done
+
+check-local: build-noinst_DSYMS
+
+clean-local: clean-noinst_DSYMS
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff -rNu valgrind-3.11.0.orig/memcheck/tests/Makefile.in valgrind-3.11.0/memcheck/tests/Makefile.in
--- valgrind-3.11.0.orig/memcheck/tests/Makefile.in	2016-03-09 20:26:02.217923922 +0100
+++ valgrind-3.11.0/memcheck/tests/Makefile.in	2016-03-09 20:49:06.995391762 +0100
@@ -130,8 +130,9 @@
 # Platform-specific tests
 @VGCONF_PLATFORMS_INCLUDE_X86_LINUX_TRUE@am__append_16 = x86-linux
 @VGCONF_PLATFORMS_INCLUDE_AMD64_LINUX_TRUE@am__append_17 = amd64-linux
-@VGCONF_PLATFORMS_INCLUDE_X86_SOLARIS_TRUE@am__append_18 = x86-solaris
-@VGCONF_PLATFORMS_INCLUDE_AMD64_SOLARIS_TRUE@am__append_19 = amd64-solaris
+@VGCONF_PLATFORMS_INCLUDE_ARM64_LINUX_TRUE@am__append_18 = arm64-linux
+@VGCONF_PLATFORMS_INCLUDE_X86_SOLARIS_TRUE@am__append_19 = x86-solaris
+@VGCONF_PLATFORMS_INCLUDE_AMD64_SOLARIS_TRUE@am__append_20 = amd64-solaris
 check_PROGRAMS = accounting$(EXEEXT) addressable$(EXEEXT) \
 	atomic_incs$(EXEEXT) badaddrvalue$(EXEEXT) badfree$(EXEEXT) \
 	badjump$(EXEEXT) badjump2$(EXEEXT) badloop$(EXEEXT) \
@@ -191,14 +192,14 @@
 	$(am__EXEEXT_5)
 
 # Sun Studio assembler fails on "IDENT too long"
-@SOLARIS_SUN_STUDIO_AS_FALSE@am__append_20 = long_namespace_xml
-@DWARF4_TRUE@am__append_21 = dw4
-@HAVE_GNU_STPNCPY_TRUE@am__append_22 = stpncpy
-@HAVE_PTHREAD_SETNAME_NP_TRUE@am__append_23 = threadname 
-@HAVE_PTHREAD_BARRIER_TRUE@am__append_24 = reach_thread_register
-@VGCONF_OS_IS_SOLARIS_TRUE@am__append_25 = -D_XOPEN_SOURCE=500
-@VGCONF_OS_IS_SOLARIS_TRUE@am__append_26 = -std=c99 -D__EXTENSIONS__
-@VGCONF_OS_IS_SOLARIS_TRUE@am__append_27 = -D_XOPEN_SOURCE=500
+@SOLARIS_SUN_STUDIO_AS_FALSE@am__append_21 = long_namespace_xml
+@DWARF4_TRUE@am__append_22 = dw4
+@HAVE_GNU_STPNCPY_TRUE@am__append_23 = stpncpy
+@HAVE_PTHREAD_SETNAME_NP_TRUE@am__append_24 = threadname 
+@HAVE_PTHREAD_BARRIER_TRUE@am__append_25 = reach_thread_register
+@VGCONF_OS_IS_SOLARIS_TRUE@am__append_26 = -D_XOPEN_SOURCE=500
+@VGCONF_OS_IS_SOLARIS_TRUE@am__append_27 = -std=c99 -D__EXTENSIONS__
+@VGCONF_OS_IS_SOLARIS_TRUE@am__append_28 = -D_XOPEN_SOURCE=500
 subdir = memcheck/tests
 ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
 am__aclocal_m4_deps = $(top_srcdir)/configure.ac
@@ -1313,9 +1314,11 @@
 SUBDIRS = . $(am__append_8) $(am__append_9) $(am__append_10) \
 	$(am__append_11) $(am__append_12) $(am__append_13) \
 	$(am__append_14) $(am__append_15) $(am__append_16) \
-	$(am__append_17) $(am__append_18) $(am__append_19)
+	$(am__append_17) $(am__append_18) $(am__append_19) \
+	$(am__append_20)
 DIST_SUBDIRS = x86 amd64 ppc32 ppc64 s390x linux \
-		darwin solaris x86-linux amd64-linux x86-solaris amd64-solaris \
+		darwin solaris x86-linux amd64-linux arm64-linux \
+		x86-solaris amd64-solaris \
 		common .
 
 dist_noinst_SCRIPTS = \
@@ -1580,7 +1583,7 @@
 descr_belowsp_LDADD = -lpthread
 err_disable3_LDADD = -lpthread
 err_disable4_LDADD = -lpthread
-err_disable4_CFLAGS = $(AM_CFLAGS) $(am__append_25)
+err_disable4_CFLAGS = $(AM_CFLAGS) $(am__append_26)
 reach_thread_register_CFLAGS = $(AM_CFLAGS) -O2
 reach_thread_register_LDADD = -lpthread
 thread_alloca_LDADD = -lpthread
@@ -1595,7 +1598,7 @@
 inltemplate_CXXFLAGS = $(AM_CXXFLAGS) @FLAG_W_NO_UNINITIALIZED@
 long_namespace_xml_SOURCES = long_namespace_xml.cpp
 manuel1_CFLAGS = $(AM_CFLAGS) @FLAG_W_NO_UNINITIALIZED@
-memalign2_CFLAGS = $(AM_CFLAGS) $(am__append_26)
+memalign2_CFLAGS = $(AM_CFLAGS) $(am__append_27)
 memcmptest_CFLAGS = $(AM_CFLAGS) -fno-builtin-memcmp
 mismatches_SOURCES = mismatches.cpp
 mismatches_CXXFLAGS = $(AM_CXXFLAGS) @FLAG_W_NO_MISMATCHED_NEW_DELETE@
@@ -1617,7 +1620,7 @@
 # because then we can't intercept it
 overlap_CFLAGS = $(AM_CFLAGS) -fno-builtin-memcpy -fno-builtin-strcpy
 resvn_stack_CFLAGS = $(AM_CFLAGS) @FLAG_W_NO_UNINITIALIZED@
-sendmsg_CFLAGS = $(AM_CFLAGS) $(am__append_27)
+sendmsg_CFLAGS = $(AM_CFLAGS) $(am__append_28)
 @VGCONF_OS_IS_SOLARIS_TRUE@sendmsg_LDADD = -lsocket -lnsl
 str_tester_CFLAGS = $(AM_CFLAGS) -Wno-shadow \
 			  @FLAG_W_NO_MEMSET_TRANSPOSED_ARGS@
commit 366319c50f4d80b33c286f37b0228b3c0e626ffa
Author: mjw <mjw@a5019735-40e9-0310-863c-91ae7b9d1cf9>
Date:   Thu Mar 10 07:59:33 2016 +0000

    Add arm64-linux to tests/platform_test.
    
    Prevent executing arm64-linux specific tests on other arches.
    
    git-svn-id: svn://svn.valgrind.org/valgrind/trunk@15827 a5019735-40e9-0310-863c-91ae7b9d1cf9

diff --git a/tests/platform_test b/tests/platform_test
index 9653921..376f62e 100644
--- a/tests/platform_test
+++ b/tests/platform_test
@@ -12,7 +12,7 @@
 
 all_platforms=
 all_platforms="$all_platforms x86-linux amd64-linux ppc32-linux ppc64-linux"
-all_platforms="$all_platforms arm-linux"
+all_platforms="$all_platforms arm-linux arm64-linux"
 all_platforms="$all_platforms s390x-linux mips32-linux mips64-linux"
 all_platforms="$all_platforms x86-darwin amd64-darwin"
 all_platforms="$all_platforms x86-solaris amd64-solaris"

commit 8f36c464966045b51a75144ca4c65f354082194f
Author: mjw <mjw@a5019735-40e9-0310-863c-91ae7b9d1cf9>
Date:   Tue Mar 15 15:08:01 2016 +0000

    Bug #360425 - arm64 unsupported instruction ldpsw tests.
    
    Add tests for ldpsw implementation VEX svn r3212.
    
    git-svn-id: svn://svn.valgrind.org/valgrind/trunk@15830 a5019735-40e9-0310-863c-91ae7b9d1cf9

diff --git a/none/tests/arm64/memory.c b/none/tests/arm64/memory.c
index cbf31fd..91949ac 100644
--- a/none/tests/arm64/memory.c
+++ b/none/tests/arm64/memory.c
@@ -280,6 +280,18 @@ TESTINST2_hide2("ldarb w21, [x22]", AREA_MID, x21,x22,0);
 
 ////////////////////////////////////////////////////////////////
 printf("STL{R,RH,RB} (entirely MISSING)\n");
+
+////////////////////////////////////////////////////////////////
+// TESTINST2_hide2 allows use of x28 as scratch
+printf("LDPSW (immediate, simm7)\n");
+
+TESTINST2_hide2("ldpsw x21, x28, [x22], #-24 ; add x21,x21,x28", AREA_MID, x21,x22,0);
+TESTINST2_hide2("ldpsw x21, x28, [x22], #-24 ; eor x21,x21,x28", AREA_MID, x21,x22,0);
+TESTINST2_hide2("ldpsw x21, x28, [x22, #-40]! ; add x21,x21,x28", AREA_MID, x21,x22,0);
+TESTINST2_hide2("ldpsw x21, x28, [x22, #-40]! ; eor x21,x21,x28", AREA_MID, x21,x22,0);
+TESTINST2_hide2("ldpsw x21, x28, [x22, #-40] ; add x21,x21,x28", AREA_MID, x21,x22,0);
+TESTINST2_hide2("ldpsw x21, x28, [x22, #-40] ; eor x21,x21,x28", AREA_MID, x21,x22,0);
+
 } /* end of test_memory_old() */
 
 
@@ -1608,6 +1620,12 @@ MEM_TEST("prfm pstl2strm, [x5,w6,uxtw #3]", 12, 4);
 MEM_TEST("prfm pstl3keep, [x5,w6,sxtw #0]", 12, 4);
 MEM_TEST("prfm pstl3strm, [x5,w6,sxtw #3]",  12, -4);
 
+////////////////////////////////////////////////////////////////
+printf("LDPSW (immediate, simm7)\n");
+MEM_TEST("ldpsw x13, x23, [x5], #-24",   0, 0);
+MEM_TEST("ldpsw x13, x23, [x5, #-40]!",  0, 0);
+MEM_TEST("ldpsw x13, x23, [x5, #-40]",   0, 0);
+
 } /* end of test_memory2() */
 
 ////////////////////////////////////////////////////////////////
diff --git a/none/tests/arm64/memory.stdout.exp b/none/tests/arm64/memory.stdout.exp
index eb6ec3f..be57108 100644
--- a/none/tests/arm64/memory.stdout.exp
+++ b/none/tests/arm64/memory.stdout.exp
@@ -98,6 +98,13 @@ ldar  w21, [x22] :: rd 00000000f3f2f1f0 rn (hidden), cin 0, nzcv 00000000
 ldarh w21, [x22] :: rd 000000000000f1f0 rn (hidden), cin 0, nzcv 00000000     
 ldarb w21, [x22] :: rd 00000000000000f0 rn (hidden), cin 0, nzcv 00000000     
 STL{R,RH,RB} (entirely MISSING)
+LDPSW (immediate, simm7)
+ldpsw x21, x28, [x22], #-24 ; add x21,x21,x28 :: rd ffffffffebe9e7e4 rn (hidden), cin 0, nzcv 00000000     
+ldpsw x21, x28, [x22], #-24 ; eor x21,x21,x28 :: rd 0000000004040404 rn (hidden), cin 0, nzcv 00000000     
+ldpsw x21, x28, [x22, #-40]! ; add x21,x21,x28 :: rd ffffffff9b999794 rn (hidden), cin 0, nzcv 00000000     
+ldpsw x21, x28, [x22, #-40]! ; eor x21,x21,x28 :: rd 0000000004040404 rn (hidden), cin 0, nzcv 00000000     
+ldpsw x21, x28, [x22, #-40] ; add x21,x21,x28 :: rd ffffffff9b999794 rn (hidden), cin 0, nzcv 00000000     
+ldpsw x21, x28, [x22, #-40] ; eor x21,x21,x28 :: rd 0000000004040404 rn (hidden), cin 0, nzcv 00000000     
 LDR,STR (immediate, uimm12)ldr  x13, [x5, #24]  with  x5 = middle_of_block+-1,  x6=0
   [  0]  .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. 
   [ 16]  .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. 
@@ -26258,3 +26265,94 @@ prfm pstl3strm, [x5,w6,sxtw #3]  with  x5 = middle_of_block+12,  x6=-4
                  0  x5       (sub, base reg)
                  0  x6       (sub, index reg)
 
+LDPSW (immediate, simm7)
+ldpsw x13, x23, [x5], #-24  with  x5 = middle_of_block+0,  x6=0
+  [  0]  .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. 
+  [ 16]  .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. 
+  [ 32]  .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. 
+  [ 48]  .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. 
+  [ 64]  .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. 
+  [ 80]  .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. 
+  [ 96]  .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. 
+  [112]  .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. 
+  [128]  .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. 
+  [144]  .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. 
+  [160]  .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. 
+  [176]  .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. 
+  [192]  .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. 
+  [208]  .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. 
+  [224]  .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. 
+  [240]  .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. 
+  5430cb99daf026bb  x13      (xor, xfer intreg #1)
+  58eb9b702726900d  x23      (xor, xfer intreg #2)
+  0000000000000000  v17.d[0] (xor, xfer vecreg #1)
+  0000000000000000  v17.d[1] (xor, xfer vecreg #1)
+  0000000000000000  v18.d[0] (xor, xfer vecreg #2)
+  0000000000000000  v18.d[1] (xor, xfer vecreg #2)
+  0000000000000000  v19.d[0] (xor, xfer vecreg #3)
+  0000000000000000  v19.d[1] (xor, xfer vecreg #3)
+  0000000000000000  v20.d[0] (xor, xfer vecreg #3)
+  0000000000000000  v20.d[1] (xor, xfer vecreg #3)
+               -24  x5       (sub, base reg)
+                 0  x6       (sub, index reg)
+
+ldpsw x13, x23, [x5, #-40]!  with  x5 = middle_of_block+0,  x6=0
+  [  0]  .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. 
+  [ 16]  .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. 
+  [ 32]  .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. 
+  [ 48]  .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. 
+  [ 64]  .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. 
+  [ 80]  .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. 
+  [ 96]  .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. 
+  [112]  .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. 
+  [128]  .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. 
+  [144]  .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. 
+  [160]  .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. 
+  [176]  .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. 
+  [192]  .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. 
+  [208]  .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. 
+  [224]  .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. 
+  [240]  .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. 
+  7f799c624bfa7f08  x13      (xor, xfer intreg #1)
+  3e7857cc51fd19f0  x23      (xor, xfer intreg #2)
+  0000000000000000  v17.d[0] (xor, xfer vecreg #1)
+  0000000000000000  v17.d[1] (xor, xfer vecreg #1)
+  0000000000000000  v18.d[0] (xor, xfer vecreg #2)
+  0000000000000000  v18.d[1] (xor, xfer vecreg #2)
+  0000000000000000  v19.d[0] (xor, xfer vecreg #3)
+  0000000000000000  v19.d[1] (xor, xfer vecreg #3)
+  0000000000000000  v20.d[0] (xor, xfer vecreg #3)
+  0000000000000000  v20.d[1] (xor, xfer vecreg #3)
+               -40  x5       (sub, base reg)
+                 0  x6       (sub, index reg)
+
+ldpsw x13, x23, [x5, #-40]  with  x5 = middle_of_block+0,  x6=0
+  [  0]  .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. 
+  [ 16]  .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. 
+  [ 32]  .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. 
+  [ 48]  .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. 
+  [ 64]  .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. 
+  [ 80]  .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. 
+  [ 96]  .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. 
+  [112]  .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. 
+  [128]  .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. 
+  [144]  .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. 
+  [160]  .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. 
+  [176]  .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. 
+  [192]  .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. 
+  [208]  .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. 
+  [224]  .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. 
+  [240]  .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. 
+  01ba3febe99768c0  x13      (xor, xfer intreg #1)
+  1cef424f7c21ff9b  x23      (xor, xfer intreg #2)
+  0000000000000000  v17.d[0] (xor, xfer vecreg #1)
+  0000000000000000  v17.d[1] (xor, xfer vecreg #1)
+  0000000000000000  v18.d[0] (xor, xfer vecreg #2)
+  0000000000000000  v18.d[1] (xor, xfer vecreg #2)
+  0000000000000000  v19.d[0] (xor, xfer vecreg #3)
+  0000000000000000  v19.d[1] (xor, xfer vecreg #3)
+  0000000000000000  v20.d[0] (xor, xfer vecreg #3)
+  0000000000000000  v20.d[1] (xor, xfer vecreg #3)
+                 0  x5       (sub, base reg)
+                 0  x6       (sub, index reg)
+
commit c10b13cb0ec8b797124d8379b7f932f92341bd4b
Author: sewardj <sewardj@8f6e269a-dfd6-0310-a8e1-e2731360e62c>
Date:   Tue Mar 15 14:24:56 2016 +0000

    arm64: implement LDPSW.  Fixes #360425.  Initial patch+investigation by Mark Wielaard.
    
    
    git-svn-id: svn://svn.valgrind.org/vex/trunk@3212 8f6e269a-dfd6-0310-a8e1-e2731360e62c

diff --git a/VEX/priv/guest_arm64_toIR.c b/VEX/priv/guest_arm64_toIR.c
index 8da9780..d4fe1b8 100644
--- a/VEX/priv/guest_arm64_toIR.c
+++ b/VEX/priv/guest_arm64_toIR.c
@@ -4804,7 +4804,6 @@ Bool dis_ARM64_load_store(/*MB_OUT*/DisResult* dres, UInt insn)
       (at-EA)
       x0 101 0010 L imm7 Rt2 Rn Rt1  mmP Rt1,Rt2, [Xn|SP, #imm]
    */
-
    UInt insn_30_23 = INSN(30,23);
    if (insn_30_23 == BITS8(0,1,0,1,0,0,0,1) 
        || insn_30_23 == BITS8(0,1,0,1,0,0,1,1)
@@ -4912,6 +4911,87 @@ Bool dis_ARM64_load_store(/*MB_OUT*/DisResult* dres, UInt insn)
       }
    }
 
+   /* -------- LDPSW (immediate, simm7) (INT REGS) -------- */
+   /* Does 32 bit transfers which are sign extended to 64 bits.
+      simm7 is scaled by the (single-register) transfer size
+
+      (at-Rn-then-Rn=EA)
+      01 101 0001 1 imm7 Rt2 Rn Rt1  LDPSW Rt1,Rt2, [Xn|SP], #imm
+   
+      (at-EA-then-Rn=EA)
+      01 101 0011 1 imm7 Rt2 Rn Rt1  LDPSW Rt1,Rt2, [Xn|SP, #imm]!
+
+      (at-EA)
+      01 101 0010 1 imm7 Rt2 Rn Rt1  LDPSW Rt1,Rt2, [Xn|SP, #imm]
+   */
+   UInt insn_31_22 = INSN(31,22);
+   if (insn_31_22 == BITS10(0,1,1,0,1,0,0,0,1,1)
+       || insn_31_22 == BITS10(0,1,1,0,1,0,0,1,1,1)
+       || insn_31_22 == BITS10(0,1,1,0,1,0,0,1,0,1)) {
+      UInt bWBack = INSN(23,23);
+      UInt rT1    = INSN(4,0);
+      UInt rN     = INSN(9,5);
+      UInt rT2    = INSN(14,10);
+      Long simm7  = (Long)sx_to_64(INSN(21,15), 7);
+      if ((bWBack && (rT1 == rN || rT2 == rN) && rN != 31)
+          || (rT1 == rT2)) {
+         /* undecodable; fall through */
+      } else {
+         if (rN == 31) { /* FIXME generate stack alignment check */ }
+
+         // Compute the transfer address TA and the writeback address WA.
+         IRTemp tRN = newTemp(Ity_I64);
+         assign(tRN, getIReg64orSP(rN));
+         IRTemp tEA = newTemp(Ity_I64);
+         simm7 = 4 * simm7;
+         assign(tEA, binop(Iop_Add64, mkexpr(tRN), mkU64(simm7)));
+
+         IRTemp tTA = newTemp(Ity_I64);
+         IRTemp tWA = newTemp(Ity_I64);
+         switch (INSN(24,23)) {
+            case BITS2(0,1):
+               assign(tTA, mkexpr(tRN)); assign(tWA, mkexpr(tEA)); break;
+            case BITS2(1,1):
+               assign(tTA, mkexpr(tEA)); assign(tWA, mkexpr(tEA)); break;
+            case BITS2(1,0):
+               assign(tTA, mkexpr(tEA)); /* tWA is unused */ break;
+            default:
+               vassert(0); /* NOTREACHED */
+         }
+
+         // 32 bit load, sign extended to 64 bits
+         putIReg64orZR(rT1, unop(Iop_32Sto64,
+                                 loadLE(Ity_I32, binop(Iop_Add64,
+                                                       mkexpr(tTA),
+                                                       mkU64(0)))));
+         putIReg64orZR(rT2, unop(Iop_32Sto64,
+                                 loadLE(Ity_I32, binop(Iop_Add64,
+                                                       mkexpr(tTA),
+                                                       mkU64(4)))));
+         if (bWBack)
+            putIReg64orSP(rN, mkexpr(tEA));
+
+         const HChar* fmt_str = NULL;
+         switch (INSN(24,23)) {
+            case BITS2(0,1):
+               fmt_str = "ldpsw %s, %s, [%s], #%lld (at-Rn-then-Rn=EA)\n";
+               break;
+            case BITS2(1,1):
+               fmt_str = "ldpsw %s, %s, [%s, #%lld]! (at-EA-then-Rn=EA)\n";
+               break;
+            case BITS2(1,0):
+               fmt_str = "ldpsw %s, %s, [%s, #%lld] (at-Rn)\n";
+               break;
+            default:
+               vassert(0);
+         }
+         DIP(fmt_str, nameIReg64orZR(rT1),
+                      nameIReg64orZR(rT2),
+                      nameIReg64orSP(rN), simm7);
+         return True;
+      }
+   }
+
    /* ---------------- LDR (literal, int reg) ---------------- */
    /* 31 29      23    4
       00 011 000 imm19 Rt   LDR   Wt, [PC + sxTo64(imm19 << 2)]
